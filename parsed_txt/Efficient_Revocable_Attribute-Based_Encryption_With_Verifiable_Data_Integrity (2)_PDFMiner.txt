This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 1 Efficient Revocable Attribute-based Encryption with Verifiable Data Integrity Shaobo Chen, Jiguo Li, Yicheng Zhang, Jinguang Han Abstract—Nowadays, cloud computing and cloud storage ser- vices that can reduce the local workload are becoming increas- ingly popular, allowing individual and corporate users to upload data to the cloud. Since the user’s permissions in the system are not immutable, the users should have dynamic access. Revocation of users who have been granted access to data is also a strong need for cloud computing systems. In addition, we should ensure the data integrity after the cloud server performs a revocation. To address above issues, we propose a revocable attribute-based encryption scheme that protects the data integrity (RABE-DI). Our scheme is more efficient compared with existing RABE-DI schemes. In addition, we prove the semantic security and integrity of the scheme. Experimental result shows that the similar scheme is not as efficient as ours. Index Terms—attribute-based encryption; full security; deci- sional linear assumption; data integrity; I. INTRODUCTION C LOUD computing and cloud storage services have be- come increasingly popular among individuals and busi- nesses in recent years because of their economical and efficient features. People store their huge data in the cloud or outsource cumbersome computing programs to the cloud while the cloud service providers charge for it. This may seem like a great give-and-take business partnership but some problems arise. In such an environment, the semantic security and integrity of the user’s data are challenged [1]–[3]. Data confidentiality is usually addressed by encrypting the data and data integrity requires verification of data. However, data in the cloud is usually shared by many users, which requires one-to-many cryptographic primitives. Attribute-based encryption (ABE) is a widely known technique that solves this problem [4]. ABE has been proven to be very suitable for access control and it is widely used in many applications like paid broadcasting, cloud services, and medical data access control. ABE has undergone significant development since its initial proposal by Sahai et al. in 2005 [5]. Notably, Waters introduced the first practical This work was supported by the National Natural Science Foundation of China (62072104, 61972095, U21A20465, 61972190, U1736112, 61772009). This work was also supported by the Natural Science Foundation of the Fujian Province, China (2020J01159). J. Li is with the College of Computer and Cyber Security, Fujian Nor- mal University, Fuzhou, China 350117 and also with the Key Labora- tory of Analytical Mathematics and Applications (Ministry of Education), Fuzhou, China 350117; Fujian Provincial Key Laboratory of Network Secu- rity and Cryptology, Fuzhou, China 350117 (Corresponding author, E-mail: ljg1688@163.com). S. Chen and Y. Zhang are with the College of Computer and Cy- ber Security, Fujian Normal University, Fuzhou, China 350117 (E-mail: m18565770601 1@163.com, Corresponding author: zyc 718@163.com). J. Han is with the School of Cyber Science and Engineering, Southeast University, Nanjing, Jiangsu 210096, China (Email: jghan22@gmail.com). version of ciphertext-policy attribute-based encryption (CP- ABE) in 2011 [6]. Over the past ten or so years, ABE has been extensively explored and extended with various functions besides access control, such as hidden access structures [7], dynamic credentials [8], key escrow-free [9], [10], multi- authority ABE [11], privacy protection [12], outsourcing com- putation [13]–[15], etc. Numerous ABE schemes [16]–[19] have been put forth in recent years to improve efficiency. Fast attribute-based message encryption (FAME) was proposed by Agrawal et al. in 2017 [17], which is an unbounded attribute space ABE scheme with quick decryption. In the FAME scheme, arbitrary strings are used as attributes and decryption inherently requires only 6 pairing operations. It is very efficient compared to the ABE scheme whose decryption cost is linearly related to the number of attributes. FAME scheme is also proven to be fully secure, compared to some classical schemes [20], [21] which only achieve selective security. Another issue is that the access structure determines what at- tribute set can satisfy it. In CP-ABE, the plaintext is encrypted into ciphertext under a particular access structure. The access structure is generated at the time of encryption and remains unchanged. How to revoke access rights from some users by changing the access structure is a challenging problem. The individual who encrypts the data, known as the data owner, should have the authority to determine which individuals or entities are granted access to the data. To illustrate this situation with an example, we consider that in a company the annual sales data is encrypted by the access structure A, which corresponds to the boolean formula T = (“accountant” ∨ “sales”). The company’s accountant and all sales of the marketing department have access to the report. Subsequently, the data owner, who is the manager of the company, seeks to enhance access privileges in order to safeguard privacy and mitigate the risk of malicious competition among employees. The new regulation requires that only management-level employees of the company have access to the report, that is, those with ‘senior’ attribute. In order to achieve this goal, the access structure for the encrypted report is therefore updated to the new access structure A′ , which corresponds to the boolean formula T = (“accountant” ∨ “sales”) ∧ (“senior”). Cloud server can realize the update of boolean formula from T to T and perform a revocation algorithm to re-encrypt the ciphertext originally encrypted under T to the ciphertext under T . After this update, some employees with “junior” attribute are revoked, because their attributes no longer satisfy the new access structure A′ , which corresponds to the boolean formula T . Fig.1 depicts this example. We consider one ′ ′ ′ ′ Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 2 (1) We present an efficient RFAME scheme with data in- tegrity. The scheme includes a mechanism to detect incorrect revocation performed by the cloud, which can be identified by the data user. (2) Our scheme does not require the data owner to perform revocation. Instead, the data owner can simply provide the cloud with a delegation, instructing it on how to perform the revocation. (3) We prove the security of our scheme by reducing it to the fully secure scheme [17]. Additionally, we prove that our scheme offers data integrity. (4) Through experiments, we assess the execution time of various algorithms, including encryption, decryption, and revocation. We illustrate the performance of our scheme and the RABE-DI scheme presented in [22]. Our scheme has more effective revocation and decryption. B. Related work A lot of work has been carried out after Sahai and Waters [5] presented the idea of ABE, which requires the attribute set to meet the access structure in order to decrypt the data. ABE is divided into two types: key-policy attribute-based encryption (KP-ABE) [23], [24] and CP-ABE [25], [26], depending on whether the access structure belongs to the private key or ciphertext. Attribute revocation is a significant research area in ABE. It presents a challenging task due to the potential involvement of numerous users when updating a single attribute. Direct revocation [27]–[29], a common form of revocation, is usually implemented in two ways. One is to add a timestamp to the key and the key generation center (KGC) broadcasts periodically to update the key. Another way is to add a revocation list to the ciphertext, which faces with the problem of excessive ciphertext size. Liu et al. [27] introduced a method of revoca- tion which is direct. This scheme incorporates the revocation list directly into the ciphertext. However, the disadvantage for this strategy is that the ciphertext’s length grows as time passes. They dealt this by eliminating the expired portion of the revocation list, thereby reducing the overall length of the ciphertext. Indirect revocation [8], [30] splits the user’s privileges of decryption into key and update material of key. The revoked user does not receive the key update material from KGC anymore and loses the decryption privileges. Cui et al. [31] introduced a method that belongs to indirect revocation. Their method builds upon the revocation method described in [32] by incorporating a binary tree and fuzzy identity-based encryption [5]. The method [32] decreases the scale of key updates from linear to logarithmic level. There are still some problems worth thinking about revocation. For example, how to revoke malicious users quickly, and how to decrease the computational burden during the revocation. The scheme [31] reduces the computational cost for data users with the help of auxiliary servers. Another issue is that the revoked user shouldn’t have the privilege to decrypt the new ciphertext after revocation, also known as revocation with forward security. Because the cloud server may perform revocation operations dishonestly, data integrity needs to be considered during the Fig. 1. Revocation process in a company more case, if the manager does not want the accountants in the company to have access to the ciphertext, he/she can revoke the attribute “accountant” by modifying the boolean formula of the access structure (“accountant” ∨ “sales”) as (“accountant” ∨ “sales”) ∧ (“sales”). Since the revocation is done by a cloud server, so the data integrity after revocation needs to be guaranteed. In our model, we consider that cloud servers store the data uploaded by users correctly but may perform computational tasks inactively or incorrectly to save their computational resources, thus failing to make sure the integrity. A. Motivations and Contributions The existing revocable attribute-based encryption (RABE) schemes often fall short in ensuring data integrity. While Ge et al. [22] introduced a RABE scheme with data integrity, their scheme is not efficient enough for achieving data integrity protection. Thus, our objective is to enhance the efficiency of revocation and decryption processes while safeguarding data integrity. To accomplish this, we leverage the advantages of FAME [17], which is a more efficient scheme in terms of both encryption and decryption. Our research focuses on imple- menting revocation mechanisms and preserving data integrity within the framework of FAME. Our main contributions are summarized as follows. Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. (cid:263)Sales(cid:264)(cid:263)Junior(cid:264)(cid:263)Engineer(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264) (cid:263)Senior(cid:264)(cid:263)Accountant(cid:264) (cid:263)SenIor(cid:264)(cid:263)Accountant(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264)(cid:263)Junior(cid:264)(cid:263)Engineer(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264) (cid:263)Senior(cid:264)(cid:263)Accountant(cid:264) (cid:263)SenIor(cid:264)(cid:263)Accountant(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264)(cid:263)Junior(cid:264)(cid:263)Engineer(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264) (cid:263)Senior(cid:264)(cid:263)Accountant(cid:264) (cid:263)SenIor(cid:264)(cid:263)Accountant(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264)(cid:263)Junior(cid:264)(cid:263)Engineer(cid:264) (cid:263)Junior(cid:264)(cid:263)Sales(cid:264) (cid:263)Senior(cid:264)(cid:263)Accountant(cid:264) (cid:263)SenIor(cid:264)(cid:263)Accountant(cid:264) (cid:263)Junior(cid:264) This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 revocation process. It implies that it’s imperative to guarantee that the encrypted data in both the newly created ciphertext from revocation and the original ciphertext are the same. Some RABE schemes [29], [30], [33] are not able to guarantee data integrity. A common solution is to verify the message being encrypted. Lai et al. [34] proposed a method to verify data integrity by giving a commitment to the message and a random message in the ciphertext. We use this verification method to ensure the data integrity of our scheme. Proxy re-encryption (PRE) is a common method in cloud services and attribute-based proxy re-encryption can be used to achieve revocation. Data owner grants the proxy server to perform re-encryption, which encrypts again on the ciphertext, achieving the effect that the original data is directly encrypted under the new access structure. Li et al. [35] presented the formal definition, security model and construction of certificate-based conditional proxy re-encryption. It is a new cryptography primitive which only the ciphertext matching one condition set by the delegatoris re-encrypted correctly by the proxy. In order to improve performance, Lu et al. [36] provided a certificate-based proxy re-encryption scheme without pairing operation. Shao et al. [37] proposed a bidirectional PRE scheme, in which a semi-trusted proxy server can convert the ciphertext under Alice’s public key and the ciphertext under Bob’s public key to each other by using a delegate key. During the whole process, the proxy server can not obtain the plaintext and the ciphertext’s size does not increase with the number of re-encryptions. Depending on the location of the access policy, attribute-based PRE is likewise categorized into ciphertext- policy attribute-based proxy re-encryption (CP-ABPRE) and key-policy attribute-based proxy re-encryption (CP-ABPRE). In order to achieve more effective fine-grained access control, Li et al. [38] proposed a CP-ABPRE scheme with key homo- morphism using restricted pseudo-random functions. In order to resist quantum attacks, Luo et al. [39] proposed the first KP-ABPRE scheme based on learning with errors problem. Proxy server can reduce the computational pressure on users, but it also brings credibility issues. It is necessary for the data user to validate the results of server execution. Recently, Ge et al. [40] proposed a verifiable PRE scheme that allows users to detect and refuse to pay for services if the proxy server does not perform correctly. Deng et al. [41] proposed a technique where a proxy server converts an ABE ciphertext to a ciphertext encrypted by identity-based encryption, thus reducing the decryption cost at the user end. II. PRELIMINARIES A. Complexity assumption Let (p, G, H, GT , e, g, h) be a prime order bilinear group system. The multiplicative cyclic groups G, H, and GT have prime order p. g and h are generator of the group G and H, respectively. If the subsequent conditions hold, then e : G × H → GT is a bilinear pairing. (1) Bilinear:e(ux, vy) = e(u, v)xy for all u ∈ G, v ∈ H and x, y ∈ Z∗ p; (2) Non-degenerate: e(u, v) ̸= 1 whenever u, v ̸= 1G; 3 (3) Computable: It’s very efficient to caculate e(u, v) for all u ∈ G, v ∈ H. Definition 1 (Discrete Logarithm Assumption [42]). Let (p, G, GT , e, g) be a bilinear group system of prime order. Given a tuple (p, G, GT , e, g, gζ) where g ∈ G, ζ ∈ Z∗ p. The discrete logarithm assumption indicates that a probabilistic polynomial time (PPT) adversary A has a negligible advan- tage in finding the integer ζ. In formal terms, the advantage of such an adversary P r[A(p, G, GT , e, g, gζ) = ζ] is negligible. B. Access structure The access structure [43] requires an attribute set to be granted permissions when its requirements are met. The fol- lowing statement provides a precise definition. Definition 2. The attribute universe is represented by the symbol U, A represents an access structure which consists of U’s non-empty subsets, i.e., A ⊆ 2U \ {0}. For any B, C ⊆ U, if B ⊆ C and B ∈ A, then C ∈ A, it is said to be monotone. From the point of comprehensibility, monotonicity suggests that a larger attribute set implies greater privileges, so adding attributes to an attribute set does not reduce its privileges but only makes it more powerful. A boolean formula T corresponds to an access structure A = (M, τ ) where M is a matrix and τ is a function. The boolean formula T determines the number of rows and columns of matrix M and τ maps M ’s row to a specific attribute. Some simple and efficient conversion methods were proposed. For instance, in [44], Liu and Cao proposed an efficient algorithm to convert the boolean formula into as small as possible matrix thus reducing the communication cost. The scheme in this work does not involve the secret recov- ery, but only the linear reconfiguration property of linear secret sharing scheme (LSSS [43]) is used, described as follows. Let S be an attribute set and I = {i|i ∈ {1, ..., n1}, τ (i) ∈ S} be the set of rows in M that corresponding to S. If there is a way to combine the rows of matrix M such that the result is equal to (1, 0, 0, ..., 0), then we describe the attribute set S as fulfilling the access structure (M, τ ). More formally, if the attribute set S satisfies the access structure (M, τ ), then there must exist a set of constant coefficients {θi}i∈I such that the following equation holds (cid:80) i∈I θiMi = (1, 0, 0, ..., 0) where Mi is the i-th row of M . We use (cid:101)A = ( (cid:102)M , (cid:101)f ) to denote the delegation access struc- ture corresponds to boolean formula (cid:101)T and A′ ) to denote the revoked access structure corresponds to boolean formula T = (M , f . ′ ′ ′ III. SYSTEM ARCHITECTURE AND DEFINITIONS A. System architecture Our RFAME system requires four entities, which are the data owner (DO), data user (DU), trusted authority center (AC), and cloud server (CS). (1) AC takes charge of setting up the entire system and generating all public parameters according to the security Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 4 parameters. The authority center also uses the master private key to create private keys for the data users. (2) DO makes the access structure and decides who can access its data accordingly. Data is encrypted under the specified access structure and transferred to the cloud. (3) CS keeps the ciphertext uploaded by data owner and performs the revocation operation. (4) Data users are able to obtain the ciphertext and recover the plaintext with their own secret key. Data users also can confirm the data integrity. B. Threat model Threat models are used to portray adversaries. Different adversaries have different capabilities and goals, this paper deals with two adversaries in the threat model [22]. The first adversary can be any entity whose main target is to compromise the confidentiality of the data. This adversary doesn’t possess a valid key, but their goal is to decrypt the ciphertext to achieve the plaintext. The second adversary, typically represented by a CS, aims to tamper with the data integrity by generating incorrect revoked ciphertext. This means that they want to corrupt the data in a way that makes it unreliable or misleading. Note that the threat model assumes there is no collaboration between CS and the revoked user. In other words, CS won’t share the original ciphertext with the revoked user, as doing so would allow the revoked user to decrypt it directly. C. Syntax of Revocable FAME with Data Integrity (RFAME- DI) Our RFAME-DI scheme is comprised of the following seven algorithms. The process of execution is depicted in Fig.2. Setup(1λ): The security parameter λ is provided as input to the authority center, which then generates the system public parameters P P and the master private key msk. KeyGen(msk, S): The authority center produces the private key sk for the data user by entering the master private key msk and the attribute set S corresponding to data user. Encrypt(m, A, P P ): The data owner uses the access struc- the message m and then outputs the ture A to encrypt ciphertext CT . Delegate((cid:101)A): The data owner takes the delegation access structure (cid:101)A as input, and then computes and takes the delega- tion DG based on the new attributes involved in (cid:101)A as output. Revoke(CT, DG): The cloud server takes the original ci- phertext CT and the delegation DG as input and takes the revoked ciphertext CT whose corresponding access structure is A′ here is T as output. The boolean formula corresponding to A′ = (T AN D (cid:101)T ). ′ ′ Decryptor(sk, CT ): The data user takes their private key sk and the original ciphertext CT as input, where the private key corresponds to the attribute set S and the access structure contained in the ciphertext CT is A. It outputs the message m, when the attribute set S matches A and the calculated checksum equals the checksum embedded in CT , else it outputs ⊥. Fig. 2. Our RFAME-DI scheme’s system architecture ′ ′ ′ , CTcsum, CT Decryptre(sk ): The data user takes their which is different from sk, a part of the original private key sk ciphertext CTcsum (explicitly, it is the checksum in CT .) and the revoked ciphertext CT downloaded from the cloud server ′ as input if the attribute set S about the private key sk matches the access structure A′ and the calculated checksum equals the CTcsum and the checksum embedded in , then it outputs the message m, else it outputs ⊥. CT in the ciphertext CT ′ ′ ′ ′ D. Security model The two security models [22] required for the RFAME-DI scheme are described separately below. IND-CPA security. Informally, if no algorithm can distinguish between m0 and m1 encrypted under the chosen access structure A∗, the scheme resists the chosen plaintext attack (CPA), as long as the algorithm is not authorized with the corresponding decryption key. Such an attack occurs at any stage of the cryptographic scheme, so the choice of the attacked access structure A∗ depends on the private key and the public parameters pos- sessed by the adversary. The scheme considered in this case will obtain adaptive or full security. In a less robust model referred to as selective security, the access structure A∗ is selected before the system is deployed so as to prevent CPA, such an idealized definition is unlikely to occur in reality. A RFAME-DI scheme achieves CPA security when the A’s advantage in the subsequent game is negligible. Setup: The challenger C runs the scheme’s Setup algorithm to produce public parameters and a master secret key during this phase. The public parameters are then shared by C and A. Query: A submits a query to obtain the secret keys skS1 , , where Si can’t satisfy the access structure A∗ that ..., skSq1 will be challenged for i ∈ {1, 2, ..., q1}. A also makes a delegation text query and gets a series of delegation texts dt1, dt2, ..., dtq2. Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. Authority centerSecret keyData ownerData ownerCloud serverCloud serverCloud serverPublic keyPublic keyUpload: CTUpload: DGDownload: CiphertextData user1. Verify integrity (included in the Decrypt)2. Recover the message mData user1. Verify integrity (included in the Decrypt)2. Recover the message m This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 Challenge: A chooses message m0 and message m1 of the same bit length. These messages are then sent to C by A. C takes these messages and generates a challenge ciphertext CT ∗ by executing the algorithm Enc(mσ, A∗). Here, σ is a randomly chosen value from the set {0, 1}. C then sends the CT ∗ back to A. Query: This phase is the same as above. Guess: A’s advantage in winning the IND-CPA secu- (λ) = is the adversary’s guess for rity game is defined by the equation AdvIN D−CP A |P r[σ σ. = σ] − 1/2|, where σ A ′ ′ Integrity. The data integrity of the RABE-DI scheme is captured by the game involving C and A. The scheme guarantees data integrity if the advantage of an adversary A is negligible. Setup: C runs the scheme’s Setup algorithm to produce public parameters and a master secret key during this phase. The public parameters are then shared by C and A. Query: A submits a query to obtain the secret keys skS1, ..., skSq . 5 TABLE I SYMBOL DESCRIPTION LIST Symbols λ P P (S, sk0, {sky}y∈S , sk ′ ) H H M τ col1 S y m, m′ e ei ⊥ Description Security parameter Public parameters Private key for attribute set S Hash function mapping {0, 1}∗ to G Hash function mapping GT to Z∗ p Matrix with n1 rows and n2 columns Row labeling function First column of matrix M Attribute set Attribute in the attribute set S Message and random value from GT Bilinear map function Ciphertext for m′ Data integrity exception symbol Challenge: A selects a message m and an access structure A and then transmits them to C. C encrypts m by algorithm Enc(m, A) and returns it’s result CT back to A. Query: This phase is the same as above. Output: set S and a revoked ciphertext CT considered to win if Decre(skS ′ , CT, CT is neither m nor ⊥. We notate the A’s advantage in winning the integrity game is P r[Awins]. A produces an attribute , where m . A is ) = m ′ ′ ′ ′ ′ IV. CONSTRUCTION In this part, we begin by presenting a revised version of the FAME construction, which includes an additional commitment to the ciphertext. Subsequently, we demonstrate that this modified version of FAME offers full security. Furthermore, we proposed the revocable FAME scheme with data integrity. The meaning of the mathematical symbols involved in the scheme are shown in Table I below. A. FAME scheme with data integrity The scheme comprises four algorithms as follows. Setup(1λ): Let (p, G, H, GT , e, g, h) be a prime order bi- linear group system. Authority center selects α1, α2 randomly from Z∗ p and selects γ1, γ2, γ3 randomly from Zp and com- putes H1 = hα1, H2 = hα2 , T1 = e(g, h)γ1α1+γ3, T2 = e(g, h)γ2α2+γ3 . Authority center also chooses two hash func- tion H : {0, 1}∗ → G and H : GT → Z∗ p and selects φ, ϕ randomly from G, then authority center outputs public parameters P P = (g, h, H1, H2, T1, T2, φ, ϕ, H, H). Authority center selects β1, β2 randomly from Z∗ p and outputs the master private key msk = (α1, α2, β1, β2, gγ1 , gγ2, gγ3). KeyGen(msk, S): Authority center selects r1, r2 ran- domly from Zp, and uses β1, β2 to compute sk0 = (hβ1r1 , hβ2r2 , hr1+r2). We use sk0,1, sk0,2, sk0,3 to represent the three subterms of sk0. Authority center selects σy, σ randomly from Zp. For z = 1, 2 and all y ∈ S, authority center computes ′ β1r1 αz · H(y2z) β2r2 αz β1r1 αz · H(012z) sk ′ sky,z = H(y1z) z = gγz · H(011z) center Authority ′ ′ 1, sk = sk (sk sk = (S, sk0, {sky}y∈S , sk ′ lets 2, gγ3−σ sky ) ′ ′ r1+r2 αz · H(y3z) β2r2 αz · H(013z) · g r1+r2 αz r1+r2 αz , ′ σ αz . · g = (sky,1, sky,2, g−σy ), key outputs secret and ) for attribute set S. 1 , H s2 Encrypt(m, A, P P ): Data owner selects s1, s2 and ˆs1, ˆs2 from Zp randomly, computes c0 = (c0,1, c0,2, c0,3) = (H s1 1 , H ˆs2 2 , hs1+s2 ) and e0 = (e0,1, e0,2, e0,3) = (H ˆs1 2 , h ˆs1+ ˆs2 ). Suppose that M is a matrix of n1 ×n2 and Mi,j is an element of M , where i and j represent the row and column number, respectively. For k = 1, 2, 3 and i = 1, ..., n1, the data owner computes ci,k = H(τ (i)k1)s1 · H(τ (i)k2)s2 · (cid:81)n2 j=1[H(0jk1)s1 · H(0jk2)s2]Mi,j , · T s2 2 Data owner lets ci = (ci,1, ci,2, ci,3) and computes ct = · m, where message m belongs to group GT , and from GT randomly. For k = 1, 2, 3 T s1 1 then data owner selects m and i = 1, ..., n1, the data owner computes ′ ′ ei,k = H(τ (i)k1) ˆs1 · H(τ (i)k2) ˆs2 · (cid:81)n2 j=1[H(0jk1) ˆs1 · H(0jk2) ˆs2]Mi,j , Data owner lets ei = (ei,1, ei,2, ei,3) and computes ct 1 · T ˆs2 T ˆs1 Data , csum = φH(m)ϕH(m′). outputs 2 · m owner CT ′ (A, c0, c1, ..., cn1, ct ′ , e0, e1, ..., en1, ct , csum). ciphertext ′′ ′′ = = Decryptor(sk, CT ): Data user checks whether the private key’s attribute set S matches the ciphertext’s access structure A = (M, τ ). If not, the algorithm aborts after printing the error symbol ⊥. Otherwise, the data user performs the following operations. Data user finds the set I ⊂ {1, 2, ..., n1} and I = {j : τ (j) ∈ S} and then finds a constant set {θi}i∈I that satisfy (cid:80) i∈I θi · Mi = (1, 0, ..., 0). Data user computes Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 6 ′ ct ·e((cid:81) i∈I cθi num = i,1, sk0,1)·e((cid:81) i∈I cθi 1 · (cid:81) i∈I skθi τ (i),2, ct0,2) · e(sk den = e(sk i∈I skθi ′ ′ i,2, sk0,2)·e((cid:81) τ (i),1, ct0,1) · e(sk 3 · (cid:81) i∈I skθi (cid:81) ′ 2 · τ (i),3, ct0,3), i∈I cθi i,3, sk0,3), and outputs m = num/den. A similar calculation can be performed for (e0, e1, ..., en1, ct . At last, if csum = φH(m)ϕH(m′) holds, the data user outputs m, otherwise outputs ⊥. ) and outputs m ′′ ′ Correctness. Here we demonstrate that when the private key sk includes the necessary attributes in A of a valid FAME ciphertext, our decryption algorithm will always recover the correct message with a certainty of 1. From the ct ′ we know that if we wish to get m, the essence 2 . For k = 1, 2, 3, using i∈I θiMi = (1, 0, 0, ..., 0), we can calculate · T s2 is that we need to compute T s1 1 the equation (cid:80) (cid:81) i∈I cθi i,k. cθi i,k = (cid:89) i∈I (cid:89) (H(τ (i)k1)θis1 · H(τ (i)k2)θis2 · i∈I n2(cid:89) [H(0jk1)s1 · j=1 H(0jk2)s2]θiMi,j ) n2(cid:89) = [H(0jk1)s1 · H(0jk2)s2] (cid:80) i∈I θiMi,j · j=1 (H(τ (i)k1)θis1 · H(τ (i)k2)θis2) (cid:89) ( i∈I = [H(01k1)s1 · H(01k2)s2] (cid:89) ( (H(τ (i)k1)θis1 · H(τ (i)k2)θis2) (cid:80) i∈I θiMi,j · i∈I This allows us to compute the last three pairing operations in num, we calculate num/ct = ′ (cid:81) t∈{1,2}[e(H(011t), h)β1r1st · e(H(012t), h)β2r2st · e(H(013t), h)(r1+r2)st · (cid:81) i∈I (e(H(τ (i)1t)θi, h)β1r1st · e(H(τ (i)2t)θi, h)β2r2st · e(H(τ (i)3t)θi, h)(r1+r2)st)]. When the above num/ct ′ and the related term in den are eliminated, we get the inverse of ((cid:81) t∈{1,2} e(gγt · g ′ σ θiστ (i) αt i∈I g αt · (cid:81) (cid:81) i∈I g−θiστ (i), hs1+s2) , hαtst)) · e(gγ3 · g−σ ′ · Simply organizing the e(g, h)γ1α1s1+γ2α2s2+γ3(s1+s2), the T s1 1 successfully. Similarly, we can obtain m get this is 2 we want. Hence, the message m is recovered above it term we is evident · T s2 that . ′ B. RFAME-DI scheme The RFAME-DI scheme is a further improvement on the FAME scheme with data integrity. The Setup, KeyGen, Encrypt, Decryptor of our RFAME-DI scheme is the same as the scheme above. To achieve revocation, we add three algorithms Delegate, Revoke and Decryptre as described below. To perform a revocation of a file, the cloud needs a delegation DG provided by the data owner of this file and the cloud performs the revocation algorithm based on the DG. To implement the delegation, the data owner randomly selects s1, s2 and saves s1, s2 as a file identifier for that file during the encryption phase. In the delegation phase, the data owner needs to use s1, s2 to generate the dt which is a part of DG. Delegate((cid:101)A): The data owner specifies an access structure (cid:101)A = ( (cid:102)M , (cid:101)τ ), where (cid:102)M is a (cid:102)n1 × (cid:102)n2 matrix and (cid:101)τ is a function that converts a row from the matrix (cid:102)M into an attribute. Then the following calculation is done for the new attributes contained in the access structure (cid:101)A and k = 1, 2, 3. i=1 H((cid:101)τ (i)k1)s1 · H((cid:101)τ (i)k1)s2 dtk = (cid:81)(cid:102)n1 Data owner lets dt = (dt1, dt2, dt3) and outputs delegation DG = (dt, (cid:101)A) for the could server. ′ , e0, e1, ..., en1, ct Revoke(CT, DG): The cloud server inputs a ciphertext CT = (A, c0, c1, ..., cn1 , ct , csum) and a delegation DG = (dt, (cid:101)A). M is a matrix with n1 rows and n2 columns and (cid:102)M is a matrix with (cid:102)n1 rows and (cid:102)n2 columns. The cloud server produces a revoked ciphertext under access structure A′ ′ ) as ). The cloud server constructs (M = (M , τ , τ ′′ ′ ′ ′  ′ M =  M | −col1 | 0 | (cid:102)M  0 , ′ τ = (cid:40) τ (j) (cid:101)τ (j − n1) j ≤ n1 j > n1 where col1 is first column of M . M ′ ′ ′ is a n ′ 1 × n ′ where n from Zp randomly and computes revoked ciphertext 2 = n2 + (cid:102)n2. The cloud selects s 1 = n1 + (cid:102)n1, n 2 matrix, ′ 1, s 2 ′ ¯ct′ = ct ′ · T s 1 · T s 2 , ¯c0 = (c0,1 · H s ′ 1 ′ 2 ¯ci,k = ci,k · H(τ (i)k1)s 1 · H(τ (i)k2)s ′ ′ ′ ′ H(0jk2)s 2 ]M i,j , where i ∈ [1, n1]. ¯ci,k = dtk · H(τ (i)k1)s 1 · H(τ (i)k2)s H(0jk2)s 2 ]M i,j , where i ∈ [n1 + 1, n ′ 1]. ′ ′ ′ 1 1 , c0,2 · H s 2 · (cid:81)n ′ ′ 2 ′ 2 2 , c0,3 · hs ′ ′ 1+s 2), j=1[H(0jk1)s ′ 1 · ′ 2 · (cid:81)n ′ 2 j=1[H(0jk1)s ′ 1 · The cloud server lets ¯ci = (¯ci,1, ¯ci,2, ¯ci,3) for i from 1 to 1 and csum = csum. The ¯e0, ¯e1, ..., ¯en1 can be gotten in the ′ n same way as above. The revoked ciphertext is CT ¯e0, ¯e1, ..., ¯en′ 1 , ¯ct′′, csum). ′ = (A′ , ¯c0, ¯c1, ..., ¯cn′ 1 , ¯ct′, ′ ′ ′ , CTcsum, CT Decryptre(sk ): The data user enters the private key sk′, which corresponds to the attribute set S ′. The data user also enters the checksum in original ciphertext CTcsum and revoked ciphertext CT the data user verifies whether csum is equal to CTcsum. If not, the data user outputs an error symbol ⊥ and aborts. In the second step, the data user checks if the attribute set S ′ meets the access structure (M ). If it doesn’t satisfy, the algorithm aborts after printing ⊥. Otherwise, the data user finds a set (j) ∈ S ′} and a set I of constants {θ p. Such that 1} where I i}i∈I ′ which elements belong to Z∗ ⊂ {1, 2, ..., n ′ = {j : τ . First, , τ ′ ′ ′ ′ ′ ′ Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 7 (cid:80) ′ ′ ′ i · M i = (1, 0, 0, ..., 0). Then, the data user calculates i∈I ′ θ m and m in the same way as in Decryptor. At last, the data user checks whether csum = φH(m)ϕH(m′). If the equation holds, the algorithm exports m, else prints ⊥. ′ Note that Decryptre can be considered as three execution phases: pre-verification, decryption, and verification. The pre- verification is to save computational cost for the user when the data integrity has been broken. If the cloud server tampers with the checksum of original ciphertext, which makes it unequal to the checksum of CT , this will cause an exception to be thrown from the pre-validation phase when the user executes Decryptre. However, this does not do the cloud server any favors and invites recourse from the user, who may believe that the cloud server has compromised the integrity in the user refusing to pay of the data. This may result the cloud service provider. A failure in the pre-verification and verification phases throws an exception of data integrity. Therefore it is reasonable to assume that the cloud server will not tamper with CTsum to affect the execution result of the user’s algorithm Decryptre. Furthermore, in practice, the data owner can generate signature for the checksum of each ciphertext he uploads so that the cloud server cannot forge it. Correctness. Algorithm Decryptre is the equivalent of the original decryption algorithm Decryptor except for the first step, the checksum of the original ciphertext CTcsum is compared with the checksum in the revoked ciphertext CT . Therefore, as long as CT is a valid ciphertext under the access ), algorithm Decryptre naturally satisfies the structure (M correctness. In the following, we show that the CT produced through Revoke is correct by lemma 1. , τ ′ ′ ′ ′ ′ Lemma 1. If the above M and (cid:102)M are valid LSSS access structures, then M is a valid LSSS access structure, and vice versa. ′ proof: Due to the fact that both (M, τ ) and ( (cid:102)M , (cid:101)τ ) are valid, there are two sets of constants {θi}i∈[1,n1] and { (cid:101)θi}i∈[1,(cid:102)n1] which elements both belong to Z∗ p, such that (cid:80) and (cid:80) i∈[1,(cid:102)n1] (cid:101)θi · (cid:102)Mi = (1, 0, 0, ..., 0) ∈ Z(cid:102)n1 p , respectively. We can then use {θi}i∈[1,n1] and { (cid:101)θi}i∈[1,(cid:102)n1] to construct {θ 1] in the following way, where n i∈[1,n1] θi · Mi = (1, 0, 0, ..., 0) ∈ Zn1 i}i∈[1,n′ p ′ ′ 1 = n1 + (cid:102)n1. (cid:40) θ ′ i = θi (cid:101)θi−n1 , i ∈ [1, n1] , i ∈ [n1 + 1, n ′ 1] It is easy to deduce from the formula that, (cid:88) θ ′ i · M ′ i = (cid:88) θi · M ′ i + (cid:88) (cid:101)θi · M ′ i+n1 i∈[1,n′ 1] i∈[1,n1] i∈[1,(cid:102)n1] n1 (cid:123) (cid:125)(cid:124) (cid:122) 1, 0, ..., 0, = ( (cid:102)n1 (cid:125)(cid:124) (cid:122) −1, 0, ..., 0) + ( (cid:123) n1 (cid:122) (cid:125)(cid:124) (cid:123) 0, ..., 0, (cid:102)n1 (cid:123) (cid:125)(cid:124) (cid:122) 1, 0, ..., 0) = (1, 0, 0, ..., 0) ∈ Zn p ′ 1 ′ ′ , τ Thus, (M Conversely, if (M i}i∈[1,n′ ′ stants {θ ) is valid LSSS access structures. ′ ′ , τ ) is valid, there exists a set of con- p, such that 1] which elements both belong to Z∗ (cid:80) i∈[1,n′ ′ {θi = θ ′ ′ i · M i = (1, 0, 0, ..., 0) ∈ Zn 1] θ i}i∈[1,n1] and { (cid:101)θi = θi+n1}i∈[1,(cid:102)n1] such that p . We can construct ′ 1 θ ′ i · M ′ i = (1, 0, 0, ..., 0) (cid:88) i∈[1,n′ 1] n1 (cid:123) (cid:125)(cid:124) (cid:122) 1, 0, ..., 0, = ( (cid:88) = θi · M i∈[1,n1] (cid:102)n1 (cid:125)(cid:124) (cid:122) −1, 0, ..., 0) + ( (cid:123) (cid:88) ′ i + i∈[1,(cid:102)n1] n1 (cid:122) (cid:125)(cid:124) (cid:123) 0, ..., 0, ′ i+n1 (cid:101)θi · M (cid:102)n1 (cid:122) (cid:123) (cid:125)(cid:124) 1, 0, ..., 0) (cid:88) = ( θi · Mi, (cid:88) i∈[1,n1] i∈[1,n1] (cid:102)n1 (cid:122) (cid:125)(cid:124) θi · ( −col1,i, 0, ..., 0)) (cid:123) (cid:88) + ( (cid:101)θi · i∈[1,(cid:102)n1] n1 (cid:122) (cid:125)(cid:124) (cid:123) (0, ..., 0), (cid:88) (cid:101)θi · (cid:102)Mi). i∈[1,(cid:102)n1] From the above equation it can be inferred that (cid:80) i∈[1,n1] θi· i∈[1,(cid:102)n1] (cid:101)θi · (cid:102)Mi = p . Thus, the LSSS access structures M and (cid:80) Mi = (1, 0, 0, ..., 0) ∈ Zn1 p (1, 0, 0, ..., 0) ∈ Z(cid:102)n1 and (cid:102)M are both valid. V. SECURITY ANALYSIS First, we prove the confidentiality of the modified FAME scheme by reducing it to the original FAME scheme. We then demonstrate the semantic security of the proposed revocable FAME with data integrity scheme. Finally, we give a data integrity proof of our formal scheme by reducing to the discrete logarithm assumption. Theorem 1. The FAME with data integrity scheme is fully IND-CPA secure if Shashank’s FAME scheme [17] is fully IND-CPA secure. Proof: The simulator B can be built to break the underlying FAME scheme’s full security by communicating with the challenger C, if a A exists that can break the security of FAME-DI scheme. • Setup. B obtains the basic parameters (p, G, H, GT , e, H1, H2, T1, T2, H) by calling C, where H1 = hα1 , H2 = hα2, T1 = e(g, h)γ1α1+γ3 , T2 = e(g, h)γ2α2+γ3 . B first selects a hash H that maps from GT to Z∗ p, and then randomly selects two elements ϕ, φ from the group G. Then B adds these to the base parameters to form the public parameters P P = (ϕ, φ, H1, H2, T1, T2, H, H) to A, and sends them to A. • Query. A queries a private key, then B queries a private key to C on the attribute set S which is the same as the query of A. Then B forwards the return of C to A. A can also initiate a delegation query to access structure (cid:101)A = ( (cid:102)M , (cid:101)τ ). B randomly selects two random numbers sa and sb and computes dtk = (cid:81)(cid:102)n1 i=1 H((cid:101)τ (i)k1)sa · H((cid:101)τ (i)k1)sb , sets dt = (dt1, dt2, dt3), then B forwards dt to A. • Challenge. A sends message m0 and message m1 of the same bit length and the access structure A∗ = (M ∗, τ ∗) intended to be challenged to B. B forwards m0, m1 and A∗ to C. C tosses a random coin to determine the value of σ ∈ {0, 1} Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 ′ ′ based on its tails and sends the challenge ciphertext about mσ encrypted with A∗ to B, denote as (A∗, c0, c1, ..., cn1 , ct ). ∈ G, Q ∈ GT and ˆs1, ˆs2 from Zp randomly. B selects m The simulator B computes e0 = (H ˆs1 2 , h ˆs1+ ˆs2) and for k = 1, 2, 3 and i = 1, ..., n1, B computes ei,k = H(f (i)k1) ˆs1· H(f (i)k2) ˆs2 · (cid:81)n2 j=1[H(0jk1) ˆs1 · H(0jk2) ˆs2]M ∗ i,j . B sets ei = · T ˆs2 = T ˆs1 · m (ei,1, ei,2, ei,3). Then B computes ct and 2 1 sets csum = Q. Eventually B sets challenge ciphertext CT = ((M ∗, f ∗), c0, c1, ..., cn1 , ct , csum) and forwards it to A. , e0, e1, ..., en1 , ct 1 , H ˆs2 ′′ ′′ ′ ′ ′ ′ σ on σ, B also guesses σ as • Query. This phase is the same as above. • Output. A gives its guess σ . Analysis. If A can break our modified scheme, B has the same advantage to compromise the FAME scheme. The simulation in the game works perfectly, except that during the challenge phase, instead of providing the calculated check value csum = φH(m)ϕH(m′), B returns a random value Q from the group GT . The important point is that A is unaware of the value of m′, so the random value Q has the same statistical distribution as the calculated check value csum. This means that the computed csum and the random value Q look the same from A’s perspective. Theorem 2. The revocable FAME with data integrity scheme is fully IND-CPA secure if the modified FAME scheme is fully IND-CPA secure. Proof: First, in the revocable FAME with data integrity scheme, the ciphertext generated by encryption algorithm Encrypt before revocation is the same as the ciphertext in the modified FAME scheme. We call the ciphertext generated by Encrypt the original ciphertext, so the original ciphertext generated by encryption in RFAME-DI achieves the same full security as the modified FAME scheme. Second, we show that the revoked ciphertext generated by the revocation Revoke and the ciphertext produced during encryption are identically distributed, these two are indistinguishable from the adversary’s view. In our RFAME-DI scheme, the ciphertext generated by the Revoke is the elements in the GT ′ 1, s generated by the value s1 + s 2 are chosen randomly and s1, s2 are in the original ciphertext. So in the adversary’s view s1 + s 2 are also chosen randomly. Thus the revocation ciphertext generated with random value s1 +s 2 and the ciphertext generated by directly encrypting under the access structure (M ) with randomly selected value s 2 are identically distributed, i.e., indistinguishable from the adversary’s viewpoint. 1 and s2 + s 1 and s2 + s 2. Where s 1, s2 +s 1 , s i.e., , τ ′′ ′′ ′ ′ ′ ′ ′ ′ ′ ′ ′ Theorem 3. If the discrete logarithm assumption holds, the revocable FMAE scheme captures the data integrity. Proof: If a malicious A attempts to compromise the RFAME-DI scheme’s integrity, it implies the existence of sim- ulator B to address the discrete logarithm problem. Simulator B inputs a discrete logarithm instance, represented by the parameters (p, G, GT , e, g, gζ). Its objective is to get the ζ as the output. • Setup. B sets a bilinear group system of prime order (p, G, GT , e, g). B selects α1, α2, β1, β2 randomly from Z∗ p 8 and select γ1, γ2, γ3, µ randomly from Zp, then chooses two hash function H : GT → Z∗ p and H : {0, 1}∗ → GT . B lets φ = gζ, ϕ = gµ and computes H1 = hα1 , H2 = hα2, T1 = e(g, h)γ1α1+γ3, T2 = e(g, h)γ2α2+γ3. Then B sends the public parameters P P = (φ, ϕ, H1, H2, T1, T2, H, H) to A. • Query. A queries a private key on the attribute set S. As B holds the master private key msk = (g, h, α1, α2, β1, β2, gγ1, gγ2, gγ3 ), B can generate the skS and provide it to A. • Challenge. A selects an access structure A = (M, f ) and a message m and provides them to the B. Note that here B is both the simulator and the challenger. The simulator B runs the Encrypt(m, (M, τ )) to obtain CT = (A, c0, c1, ..., cn1, ct , csum), where csum = φH(m)ϕH(m is randomly selected during the encryption process. B sends CT to the A. , e0, e1, ..., en1 , ct ) and m ′′ ′ ′ ′ • Query. This phase is the same as above. • Output. A gives a revoked ciphertext under the revoked , ¯ct′, ¯e0, = (M ), ¯c0, ¯c1, ..., ¯cn′ = (A′ , τ ′ ′ ′ 1 access structure CT ¯e1, ..., ¯en′ , ¯ct′′, csum). 1 ′ ′ At this point, simulator B can choose an attribute set S that satisfies the revoked access structure M and then use the master private key to generate the corresponding private keyskS ′ , which is then used to decrypt CT to obtain the encrypted message. Denote the decrypted real message and random message to be ¯m and ¯m′ respectively. If A can break data integrity, then it means ¯m ̸= m and ¯m′ ̸= m but csum = csum. So that B can calculate ζ by the following computation and return ζ as its answer for discrete logarithm assumption. ′ ′ csum = csum ⇔ φH(m)ϕH(m ′ ) = φH( ¯m)ϕH( ¯m′ ) ′ ⇔ gζ·H(m)+µ·H(m ⇔ ζ · (H(m) − H( ¯m)) = µ · (H( ¯m′) − H(m ) = gζ·H( ¯m)+µ·H( ¯m′ ) ′ )) ⇒ ζ = µ·(H( ¯m′ )−H(m H(m)−H( ¯m) ′ )) . Analysis. The simulation of B in the game is flawless, and the B’s advantage in solving the discrete logarithmic hard problem is identical to the adversary A’s advantage in winning the above game. VI. IMPLEMENTATION & EVALUATION We put our scheme into action and assess its feasibility by considering the computational expenses involved, we also do a property-wise comparison of our scheme with other RABE schemes [22], [27], [31], [45] in Table II. We implement our scheme on a laptop with AMD’s CPU. It’s Ryzon 7 5800H @3.2GHz with 4GB RAM. Both the client and cloud server utilize the Linux Ubuntu 20.04 operating system. We use the library charm 0.5.0 in Python to write the code and run it with version 2.7.15 of Python. It is possible to carry our scheme on type III curves, such as MNT and BN curves, but some MNT and BN curves are known to be insecure in some parameters, so be sure to choose elliptic curves carefully when implementing cryptographic schemes. We implement our scheme on the type III curve MNT224 Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 9 TABLE II COMPARISON OF VARIOUS RABE SCHEMES Scheme Type of revocation Data integrity Attribute space Arbitrary attributes Security Computation Cost in decryption [22] [27] [31] [45] Re-encryption Direct Indirect Indirect Ours Re-encryption Yes No No No Yes Bounded Bounded Bounded Unbounded Unbounded No No No Yes Yes Selective Selective Selective Full Full Linear Linear Constant Constant Constant in PBC, which is widely acknowledged for its exceptional balance between security and efficiency. Since there are AND-gates and OR-gates in the randomly generated access structure, how many attributes are used in decryption is not determined by the access structure size, and only some attributes are needed to participate in the calculation to complete the decryption. Therefore, the access structure we generate for testing only contains AND-gates, the goal is to ensure that the amount of attributes needed for decryption matches the access structure size. We also do the same test 50 times and averaged the results to get more realistic and accurate time data. Specifically in the experiment, for the three algorithms Encrypt, Decryptor, and Revoke, the attribute set and access structure are adjusted in increments of 10, ranging from a minimum of 10 to a maximum of 100. The horizontal coordinates of the experimental images of Revoke represent the size of A′ the access structure size is from 20 to 200 with a step of 20. In fact, there is no difference between the two algorithms Decryptor and Decryptre, but Decryptre does one more equation verification operation than Decryptor, i.e., verifying whether the CTcsum item from the original ciphertext is equal to csum in the revoked ciphertext, and this operation is very light and its time consumption is negligible. We can see from the Fig.4 and Fig.6 that the performance of the Decryptre algorithm is almost the same as that of the Decryptor algorithm in the set size range from 10 to 100. . For the algorithm Decryptre, Fig. 4. Decryption time of RFAME-DI scheme and compared scheme Fig. 5. Revocation time of RFAME-DI scheme and compared scheme of the revoked ciphertext. Especially in the decryption phases, where the time consumed in our scheme for decryption is independent of the set size, which is stable at about 36ms regardless of the set size. This is because the decryption process of FAME only needs 6 pairing operations. Our scheme has acceptable disadvantages and very large advantages in practical applications. Because the KGC, which has adequate computational capability, manages key generation and the algorithm is usually executed only once for one user. The client device handles both encryption and decryption tasks, so it’s crucial for the computational load to be as minimal as possible. Since ABE is a one-to-many encryption technique, so decryption occurs more frequently than encryption in practical scenarios. Our scheme happens to exactly has a significant advantage in decryption. Fig. 3. Encryption time of RFAME-DI scheme and compared scheme We compare our scheme with the scheme [22]. From Fig.6- 9, we see that our scheme outperforms the scheme [22] in all four phases: encryption, decryption, revocation, and decryption Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. 02040608010002004006008001000Encryption (ms)Access policy size Our Scheme Scheme[18]0204060801000100200300400500600Decryption (ms)Attribute set size Our Scheme Scheme[18]0501001502000500100015002000Revocation (ms)Revoked access policy size Our Scheme Scheme[18] This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 10 [8] A. Sahai, H. Seyalioglu, and B. Waters, “Dynamic credentials and ciphertext delegation for attribute-based encryption,” Advances in Cryp- tology - CRYPTO 2012, LNCS, vol. 7417, pp. 199–217, 2012. [9] R. Zhang, J. Li, Y. Lu, J. Han, and Y. Zhang, “Key escrow-free attribute based encryption with user revocation,” Inf. Sci., vol. 600, pp. 59–72, 2022. [10] Y. Guo, Z. Lu, H. Ge, and J. Li, “Revocable blockchain-aided attribute- based encryption with escrow-free in cloud storage,” IEEE Trans. Computers, vol. 72, no. 7, pp. 1901–1912, 2023. [11] J. Li, R. Zhang, Y. Lu, J. Han, Y. Zhang, W. Zhange, and X. Dong, “Multi-authority attribute-based encryption for assuring data deletion,” IEEE Systems Journal, 2022. [12] J. Li, Y. Zhang, J. Ning, X. Huang, G. S. Poh, and D. Wang, “At- tribute based encryption with privacy protection and accountability for cloudiot,” IEEE Trans. Cloud Comput., vol. 10, no. 2, pp. 762–773, 2022. [13] J. Hur and D. K. Noh, “Attribute-based access control with efficient re- vocation in data outsourcing systems,” IEEE Trans. Parallel Distributed Syst., vol. 22, no. 7, pp. 1214–1221, 2011. [14] J. Li, X. Huang, J. Li, X. Chen, and Y. Xiang, “Securely outsourc- ing attribute-based encryption with checkability,” IEEE Trans. Parallel Distributed Syst., vol. 25, no. 8, pp. 2201–2210, 2014. [15] J. Li, Y. Wang, Y. Zhang, and J. Han, “Full verifiability for outsourced decryption in attribute based encryption,” IEEE Trans. Serv. Comput., vol. 13, no. 3, pp. 478–487, 2020. [16] N. Chen, J. Li, Y. Zhang, and Y. Guo, “Efficient CP-ABE scheme with shared decryption in cloud storage,” IEEE Trans. Computers, vol. 71, no. 1, pp. 175–184, 2022. [17] S. Agrawal and M. Chase, “FAME: fast attribute-based message encryp- tion,” in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017, pp. 665–682. [18] D. Riepel and H. Wee, “FABEO: fast attribute-based encryption with optimal security,” in Proceedings of the 2022 ACM SIGSAC Confer- ence on Computer and Communications Security, H. Yin, A. Stavrou, C. Cremers, and E. Shi, Eds. ACM, 2022, pp. 2491–2504. [19] M. Ambrona, G. Barthe, R. Gay, and H. Wee, “Attribute-based en- cryption in the generic group model: Automated proofs and new constructions,” in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2017, pp. 647– 664. [20] R. Ostrovsky, A. Sahai, and B. Waters, “Attribute-based encryption with non-monotonic access structures,” in Proceedings of the 2007 ACM Conference on Computer and Communications Security. ACM, 2007, pp. 195–203. [21] V. Goyal, A. Jain, O. Pandey, and A. Sahai, “Bounded ciphertext policy attribute based encryption,” in Automata, Languages and Programming, 35th International Colloquium, vol. 5126. Springer, 2008, pp. 579–591. [22] C. Ge, W. Susilo, J. Baek, Z. Liu, J. Xia, and L. Fang, “Revocable attribute-based encryption with data integrity in clouds,” IEEE Trans. Dependable Secur. Comput., vol. 19, no. 5, pp. 2864–2872, 2022. [23] N. Attrapadung, B. Libert, and E. de Panafieu, “Expressive key-policy attribute-based encryption with constant-size ciphertexts,” in Public Key Cryptography - PKC 2011, LNCS, vol. 6571. Springer, 2011, pp. 90– 108. [24] J. Han, W. Susilo, Y. Mu, and J. Yan, “Privacy-preserving decentralized key-policy attribute-based encryption,” IEEE Trans. Parallel Distributed Syst., vol. 23, no. 11, pp. 2150–2162, 2012. [25] J. Li, W. Yao, J. Han, Y. Zhang, and J. Shen, “User collusion avoidance CP-ABE with efficient attribute revocation for cloud storage,” IEEE Syst. J., vol. 12, no. 2, pp. 1767–1777, 2018. [26] J. Li, W. Yao, Y. Zhang, H. Qian, and J. Han, “Flexible and fine- grained attribute-based data storage in cloud computing,” IEEE Trans. Serv. Comput., vol. 10, no. 5, pp. 785–796, 2017. [27] J. K. Liu, T. H. Yuen, P. Zhang, and K. Liang, “Time-based direct revo- cable ciphertext-policy attribute-based encryption with short revocation list,” in Applied Cryptography and Network Security, ACNS 2018, LNCS, vol. 10892. Springer, 2018, pp. 516–534. [28] Y. Shi, Q. Zheng, J. Liu, and Z. Han, “Directly revocable key-policy attribute-based encryption with verifiable ciphertext delegation,” Inf. Sci., vol. 295, pp. 221–231, 2015. [29] H. Wang, Z. Zheng, L. Wu, and P. Li, “New directly revocable attribute-based encryption scheme and its application in cloud storage environment,” Clust. Comput., vol. 20, no. 3, pp. 2385–2392, 2017. [30] Y. Yang, J. K. Liu, K. Liang, K. R. Choo, and J. Zhou, “Extended proxy- assisted approach: Achieving revocable fine-grained encryption of cloud data,” in 20th European Symposium on Research in Computer Security, vol. 9327. Springer, 2015, pp. 146–166. Fig. 6. Revoked ciphertext decryption time of RFAME-DI scheme and compared scheme The outcomes of the experiment show the effectiveness and feasibility of our revocation scheme in ensuring data integrity. VII. CONCLUSION In this paper, we introduce a practical and effective RFAME scheme designed to safeguard the data integrity on the cloud, thereby minimizing performance limitations both for the data users and the cloud. We reduce the security of our scheme to the FAME scheme to show its full security. We also demonstrate the data integrity of our scheme in an adaptive model under discrete logarithm assumption. Furthermore, we conduct simulation experiments and experimental analysis in- dicates that our scheme’s efficiency surpasses the comparison scheme in encryption, decryption, and revocation algorithms. In addition, our scheme achieves efficient attribute-based re- vocation while protecting data integrity, but the essence of revocation is an update of the access structure. It will affect the access of some data users to the file. Our future work is to implement more fine-grained revocation, enabling data owners to withdraw access to a single file for a specific user. REFERENCES [1] Z. Kang, J. Li, J. Shen, J. Han, Y. Zuo, and Y. Zhang, “TFS-ABS: traceable and forward-secure attribute-based signature scheme with constant-size,” IEEE Trans. Knowl. Data Eng., vol. 35, no. 9, pp. 9514– 9530, 2023. [2] Y. Chen, J. Li, C. Liu, J. Han, Y. Zhang, and P. Yi, “Efficient attribute based server-aided verification signature,” IEEE Trans. Serv. Comput., vol. 15, no. 6, pp. 3224–3232, 2022. [3] J. Li, Y. Chen, J. Han, C. Liu, Y. Zhang, and H. Wang, “Decentralized attribute-based server-aid signature in the internet of things,” IEEE Internet Things J., vol. 9, no. 6, pp. 4573–4583, 2022. [4] L. Zhang, H. Xiong, Q. Huang, J. Li, K. R. Choo, and J. Li, “Cryptographic solutions for cloud storage: Challenges and research opportunities,” IEEE Trans. Serv. Comput., vol. 15, no. 1, pp. 567–587, 2022. [5] A. Sahai and B. Waters, “Fuzzy identity-based encryption,” in 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, 2005, pp. 457–473. [6] B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in 14th International Confer- ence on Practice and Theory in Public Key Cryptography, vol. 6571. Springer, 2011, pp. 53–70. [7] K. B. Frikken, M. J. Atallah, and J. Li, “Attribute-based access control with hidden policies and hidden credentials,” IEEE Trans. Computers, vol. 55, no. 10, pp. 1259–1270, 2006. Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information. 050100150200020040060080010001200Revoked ciphertext decryption (ms)Access policy size Our Scheme Scheme[18] This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 [31] H. Cui, R. H. Deng, Y. Li, and B. Qin, “Server-aided revocable attribute- based encryption,” in Computer Security - ESORICS 2016, LNCS, vol. 9879. Springer, 2016, pp. 570–587. [32] A. Boldyreva, V. Goyal, and V. Kumar, “Identity-based encryption with efficient revocation,” in Proceedings of the 2008 ACM Conference on Computer and Communications Security. ACM, 2008, pp. 417–426. [33] Y. Jiang, W. Susilo, Y. Mu, and F. Guo, “Ciphertext-policy attribute- based encryption supporting access policy update and its extension with preserved attributes,” Int. J. Inf. Sec., vol. 17, no. 5, pp. 533–548, 2018. [34] J. Lai, R. H. Deng, C. Guan, and J. Weng, “Attribute-based encryption with verifiable outsourced decryption,” IEEE Trans. Inf. Forensics Secur., vol. 8, no. 8, pp. 1343–1354, 2013. [35] J. Li, X. Zhao, Y. Zhang, and W. Yao, “Provably secure certificate- based conditional proxy re-encryption,” J. Inf. Sci. Eng., vol. 32, no. 4, pp. 813–830, 2016. [36] Y. Lu and J. Li, “A pairing-free certificate-based proxy re-encryption scheme for secure data sharing in public clouds,” Future Gener. Comput. Syst., vol. 62, pp. 140–147, 2016. [37] J. Shao, R. Lu, X. Lin, and K. Liang, “Secure bidirectional proxy re- encryption for cryptographic cloud storage,” Pervasive Mob. Comput., vol. 28, pp. 113–121, 2016. [38] Z. Li, V. Sharma, C. Ma, C. Ge, and W. Susilo, “Ciphertext-policy attribute-based proxy re-encryption via constrained prfs,” Sci. China Inf. Sci., vol. 64, no. 6, 2021. [39] F. Luo, S. M. Al-Kuwari, F. Wang, and K. Chen, “Attribute-based proxy re-encryption from standard lattices,” Theor. Comput. Sci., vol. 865, pp. 52–62, 2021. [40] C. Ge, W. Susilo, J. Baek, Z. Liu, J. Xia, and L. Fang, “A verifiable and fair attribute-based proxy re-encryption scheme for data sharing in clouds,” IEEE Trans. Dependable Secur. Comput., vol. 19, no. 5, pp. 2907–2919, 2022. [41] H. Deng, Z. Qin, Q. Wu, Z. Guan, and Y. Zhou, “Flexible attribute- based proxy re-encryption for efficient data sharing,” Inf. Sci., vol. 511, pp. 94–113, 2020. [42] A. Sadeghi and M. Steiner, “Assumptions related to discrete logarithms: Why subtleties make a real difference,” Advances in Cryptology - EUROCRYPT 2001, vol. 2045, pp. 244–261, 2001. [43] A. Beimel, “Secure schemes for secret sharing and key distribution,” Ph.D. dissertation, Technion - Israel Institute of Technology, Israel, 1996. [44] Z. Liu and Z. Cao, “On efficiently transferring the linear secret-sharing scheme matrix in ciphertext-policy attribute-based encryption,” IACR Cryptol. ePrint Arch., p. 374, 2010. [45] S. Xu, J. Ning, J. Ma, G. Xu, J. Yuan, and R. H. Deng, “Revocable policy-based chameleon hash,” in 26th European Symposium on Re- search in Computer Security, ser. Lecture Notes in Computer Science, E. Bertino, H. Shulman, and M. Waidner, Eds., vol. 12972. Springer, 2021, pp. 327–347. 11 Jiguo Li received the Ph.D. degree in computer science from Harbin Institute of Technology, Harbin, China, in 2003. During 2006.9-2007.3, he was a visiting scholar at Centre for Computer and Informa- tion Security Research, University of Wollongong, Australia. During 2013.2-2014.1, he was a visiting scholar in Institute for Cyber Security in the Uni- versity of Texas at San Antonio. From November 2003 to October 2018, he was with the College of Computers and Information, Hohai University, Nanjing, China. He is currently a professor with the College of Computer and Cyber Security, Fujian Normal University, Fuzhou, China. His research interests include cryptography theory and technology, information security, and cloud computing security etc. He has published over 200 research papers in refereed international conferences and journals. His work has been cited more than 5000 times at Google Scholar. He has served as program committee member in over 40 international conferences and served as the reviewers in over 100 international journals and conferences. Yichen Zhang received the Ph.D. degree in the Col- lege of Computer and Information, Hohai University, Nanjing, China in 2015. She is currently an associate professor with the College of Mathematics and In- formatics, Fujian Normal University, Fuzhou, China. Her research interests include cryptography, network security. She has published over 40 research papers in refereed international conferences and journals. ShaoBo Chen received the B.S. degree in math- ematics from Southern University of Science and Technology, China, in 2019. He is working for M.S. degree in the College of Computer and Cyber Secu- rity, Fujian Normal University, Fuzhou, China. His research interests include attribute-based encryption, could security and privacy. Jinguang Han obtained his PhD degree from Uni- versity of Wollongong, Australia, in 2013. He is a professor at the School of Cyber Science and Engineering, Southeast University, China. His re- search interests include cryptography, access control, blockchain, privacy-preserving systems, cloud com- puting and network security. He is a senior member of ACM and IEEE. Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.(cid:13) (cid:10)See https://www.ieee.org/publications/rights/index.html for more information.