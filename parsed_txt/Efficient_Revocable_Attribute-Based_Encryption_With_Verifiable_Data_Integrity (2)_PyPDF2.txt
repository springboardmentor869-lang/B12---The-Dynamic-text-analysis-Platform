1 Efficient Revocable Attribute-based Encryption with Verifiable Data Integrity Shaobo Chen ,Jiguo Li ,Yicheng Zhang ,Jinguang Han Abstract —Nowadays, cloud computing and cloud storage ser- vices that can reduce the local workload are becoming increas- ingly popular, allowing individual and corporate users to upload data to the cloud. Since the user’s permissions in the system are not immutable, the users should have dynamic access. Revocation of users who have been granted access to data is also a strong need for cloud computing systems. In addition, we should ensure the data integrity after the cloud server performs a revocation. To address above issues, we propose a revocable attribute-based encryption scheme that protects the data integrity (RABE-DI). Our scheme is more efficient compared with existing RABE-DI schemes. In addition, we prove the semantic security and integrity of the scheme. Experimental result shows that the similar scheme is not as efficient as ours. Index Terms —attribute-based encryption; full security; deci- sional linear assumption; data integrity; I. I NTRODUCTION CLOUD computing and cloud storage services have be- come increasingly popular among individuals and busi- nesses in recent years because of their economical and efficient features. People store their huge data in the cloud or outsource cumbersome computing programs to the cloud while the cloud service providers charge for it. This may seem like a great give-and-take business partnership but some problems arise. In such an environment, the semantic security and integrity of the user’s data are challenged [1]–[3]. Data confidentiality is usually addressed by encrypting the data and data integrity requires verification of data. However, data in the cloud is usually shared by many users, which requires one-to-many cryptographic primitives. Attribute-based encryption (ABE) is a widely known technique that solves this problem [4]. ABE has been proven to be very suitable for access control and it is widely used in many applications like paid broadcasting, cloud services, and medical data access control. ABE has undergone significant development since its initial proposal by Sahai et al. in 2005 [5]. Notably, Waters introduced the first practical This work was supported by the National Natural Science Foundation of China (62072104, 61972095, U21A20465, 61972190, U1736112, 61772009). This work was also supported by the Natural Science Foundation of the Fujian Province, China (2020J01159). J. Li is with the College of Computer and Cyber Security, Fujian Nor- mal University, Fuzhou, China 350117 and also with the Key Labora- tory of Analytical Mathematics and Applications (Ministry of Education), Fuzhou, China 350117; Fujian Provincial Key Laboratory of Network Secu- rity and Cryptology, Fuzhou, China 350117 (Corresponding author, E-mail: ljg1688@163.com). S. Chen and Y . Zhang are with the College of Computer and Cy- ber Security, Fujian Normal University, Fuzhou, China 350117 (E-mail: m18565770601 1@163.com, Corresponding author: zyc 718@163.com). J. Han is with the School of Cyber Science and Engineering, Southeast University, Nanjing, Jiangsu 210096, China (Email: jghan22@gmail.com).version of ciphertext-policy attribute-based encryption (CP- ABE) in 2011 [6]. Over the past ten or so years, ABE has been extensively explored and extended with various functions besides access control, such as hidden access structures [7], dynamic credentials [8], key escrow-free [9], [10], multi- authority ABE [11], privacy protection [12], outsourcing com- putation [13]–[15], etc. Numerous ABE schemes [16]–[19] have been put forth in recent years to improve efficiency. Fast attribute-based message encryption (FAME) was proposed by Agrawal et al. in 2017 [17], which is an unbounded attribute space ABE scheme with quick decryption. In the FAME scheme, arbitrary strings are used as attributes and decryption inherently requires only 6 pairing operations. It is very efficient compared to the ABE scheme whose decryption cost is linearly related to the number of attributes. FAME scheme is also proven to be fully secure, compared to some classical schemes [20], [21] which only achieve selective security. Another issue is that the access structure determines what at- tribute set can satisfy it. In CP-ABE, the plaintext is encrypted into ciphertext under a particular access structure. The access structure is generated at the time of encryption and remains unchanged. How to revoke access rights from some users by changing the access structure is a challenging problem. The individual who encrypts the data, known as the data owner, should have the authority to determine which individuals or entities are granted access to the data. To illustrate this situation with an example, we consider that in a company the annual sales data is encrypted by the access structure A, which corresponds to the boolean formula T= (“ accountant ”∨“sales ”). The company’s accountant and all sales of the marketing department have access to the report. Subsequently, the data owner, who is the manager of the company, seeks to enhance access privileges in order to safeguard privacy and mitigate the risk of malicious competition among employees. The new regulation requires that only management-level employees of the company have access to the report, that is, those with ‘senior’ attribute. In order to achieve this goal, the access structure for the encrypted report is therefore updated to the new access structure A′, which corresponds to the boolean formula T′= (“accountant ”∨“sales ”)∧(“senior ”). Cloud server can realize the update of boolean formula from T toT′and perform a revocation algorithm to re-encrypt the ciphertext originally encrypted under Tto the ciphertext under T′. After this update, some employees with “junior” attribute are revoked, because their attributes no longer satisfy the new access structure A′, which corresponds to the boolean formula T′. Fig.1 depicts this example. We consider oneThis article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 2 ćSales Ĉ ćJunior ĈćEngineer Ĉ ćJunior ĈćSales Ĉ ćSenior ĈćAccountant Ĉ ćSenIor ĈćAccountant Ĉ ćJunior Ĉ ćSales Ĉ ćJunior ĈćEngineer Ĉ ćJunior ĈćSales Ĉ ćSenior ĈćAccountant Ĉ ćSenIor ĈćAccountant Ĉ ćJunior Ĉ ćSales Ĉ ćJunior ĈćEngineer Ĉ ćJunior ĈćSales Ĉ ćSenior ĈćAccountant Ĉ ćSenIor ĈćAccountant Ĉ ćJunior Ĉ ćSales Ĉ ćJunior ĈćEngineer Ĉ ćJunior ĈćSales Ĉ ćSenior ĈćAccountant Ĉ ćSenIor ĈćAccountant Ĉ ćJunior Ĉ Fig. 1. Revocation process in a company more case, if the manager does not want the accountants in the company to have access to the ciphertext, he/she can revoke the attribute “accountant” by modifying the boolean formula of the access structure (“accountant ”∨“sales ”)as (“accountant ”∨“sales ”)∧(“sales ”). Since the revocation is done by a cloud server, so the data integrity after revocation needs to be guaranteed. In our model, we consider that cloud servers store the data uploaded by users correctly but may perform computational tasks inactively or incorrectly to save their computational resources, thus failing to make sure the integrity. A. Motivations and Contributions The existing revocable attribute-based encryption (RABE) schemes often fall short in ensuring data integrity. While Ge et al. [22] introduced a RABE scheme with data integrity, their scheme is not efficient enough for achieving data integrity protection. Thus, our objective is to enhance the efficiency of revocation and decryption processes while safeguarding data integrity. To accomplish this, we leverage the advantages of FAME [17], which is a more efficient scheme in terms of both encryption and decryption. Our research focuses on imple- menting revocation mechanisms and preserving data integrity within the framework of FAME. Our main contributions are summarized as follows.(1) We present an efficient RFAME scheme with data in- tegrity. The scheme includes a mechanism to detect incorrect revocation performed by the cloud, which can be identified by the data user. (2) Our scheme does not require the data owner to perform revocation. Instead, the data owner can simply provide the cloud with a delegation, instructing it on how to perform the revocation. (3) We prove the security of our scheme by reducing it to the fully secure scheme [17]. Additionally, we prove that our scheme offers data integrity. (4) Through experiments, we assess the execution time of various algorithms, including encryption, decryption, and revocation. We illustrate the performance of our scheme and the RABE-DI scheme presented in [22]. Our scheme has more effective revocation and decryption. B. Related work A lot of work has been carried out after Sahai and Waters [5] presented the idea of ABE, which requires the attribute set to meet the access structure in order to decrypt the data. ABE is divided into two types: key-policy attribute-based encryption (KP-ABE) [23], [24] and CP-ABE [25], [26], depending on whether the access structure belongs to the private key or ciphertext. Attribute revocation is a significant research area in ABE. It presents a challenging task due to the potential involvement of numerous users when updating a single attribute. Direct revocation [27]–[29], a common form of revocation, is usually implemented in two ways. One is to add a timestamp to the key and the key generation center (KGC) broadcasts periodically to update the key. Another way is to add a revocation list to the ciphertext, which faces with the problem of excessive ciphertext size. Liu et al. [27] introduced a method of revoca- tion which is direct. This scheme incorporates the revocation list directly into the ciphertext. However, the disadvantage for this strategy is that the ciphertext’s length grows as time passes. They dealt this by eliminating the expired portion of the revocation list, thereby reducing the overall length of the ciphertext. Indirect revocation [8], [30] splits the user’s privileges of decryption into key and update material of key. The revoked user does not receive the key update material from KGC anymore and loses the decryption privileges. Cui et al. [31] introduced a method that belongs to indirect revocation. Their method builds upon the revocation method described in [32] by incorporating a binary tree and fuzzy identity-based encryption [5]. The method [32] decreases the scale of key updates from linear to logarithmic level. There are still some problems worth thinking about revocation. For example, how to revoke malicious users quickly, and how to decrease the computational burden during the revocation. The scheme [31] reduces the computational cost for data users with the help of auxiliary servers. Another issue is that the revoked user shouldn’t have the privilege to decrypt the new ciphertext after revocation, also known as revocation with forward security. Because the cloud server may perform revocation operations dishonestly, data integrity needs to be considered during theThis article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 3 revocation process. It implies that it’s imperative to guarantee that the encrypted data in both the newly created ciphertext from revocation and the original ciphertext are the same. Some RABE schemes [29], [30], [33] are not able to guarantee data integrity. A common solution is to verify the message being encrypted. Lai et al. [34] proposed a method to verify data integrity by giving a commitment to the message and a random message in the ciphertext. We use this verification method to ensure the data integrity of our scheme. Proxy re-encryption (PRE) is a common method in cloud services and attribute-based proxy re-encryption can be used to achieve revocation. Data owner grants the proxy server to perform re-encryption, which encrypts again on the ciphertext, achieving the effect that the original data is directly encrypted under the new access structure. Li et al. [35] presented the formal definition, security model and construction of certificate-based conditional proxy re-encryption. It is a new cryptography primitive which only the ciphertext matching one condition set by the delegatoris re-encrypted correctly by the proxy. In order to improve performance, Lu et al. [36] provided a certificate-based proxy re-encryption scheme without pairing operation. Shao et al. [37] proposed a bidirectional PRE scheme, in which a semi-trusted proxy server can convert the ciphertext under Alice’s public key and the ciphertext under Bob’s public key to each other by using a delegate key. During the whole process, the proxy server can not obtain the plaintext and the ciphertext’s size does not increase with the number of re-encryptions. Depending on the location of the access policy, attribute-based PRE is likewise categorized into ciphertext- policy attribute-based proxy re-encryption (CP-ABPRE) and key-policy attribute-based proxy re-encryption (CP-ABPRE). In order to achieve more effective fine-grained access control, Li et al. [38] proposed a CP-ABPRE scheme with key homo- morphism using restricted pseudo-random functions. In order to resist quantum attacks, Luo et al. [39] proposed the first KP-ABPRE scheme based on learning with errors problem. Proxy server can reduce the computational pressure on users, but it also brings credibility issues. It is necessary for the data user to validate the results of server execution. Recently, Ge et al. [40] proposed a verifiable PRE scheme that allows users to detect and refuse to pay for services if the proxy server does not perform correctly. Deng et al. [41] proposed a technique where a proxy server converts an ABE ciphertext to a ciphertext encrypted by identity-based encryption, thus reducing the decryption cost at the user end. II. PRELIMINARIES A. Complexity assumption Let(p,G,H,GT, e, g, h )be a prime order bilinear group system. The multiplicative cyclic groups G,H, andGThave prime order p.gandhare generator of the group Gand H, respectively. If the subsequent conditions hold, then e: G×H→GTis a bilinear pairing. (1) Bilinear: e(ux, vy) =e(u, v)xyfor all u∈G, v∈Hand x, y∈Z∗ p; (2) Non-degenerate: e(u, v)̸= 1 whenever u, v̸= 1G;(3) Computable: It’s very efficient to caculate e(u, v)for all u∈G, v∈H. Definition 1 (Discrete Logarithm Assumption [42]) .Let (p,G,GT, e, g)be a bilinear group system of prime order. Given a tuple (p,G,GT, e, g, gζ)where g∈G, ζ∈Z∗ p. The discrete logarithm assumption indicates that a probabilistic polynomial time (PPT) adversary Ahas a negligible advan- tage in finding the integer ζ. In formal terms, the advantage of such an adversary Pr[A(p,G,GT, e, g, gζ) =ζ]is negligible. B. Access structure The access structure [43] requires an attribute set to be granted permissions when its requirements are met. The fol- lowing statement provides a precise definition. Definition 2. The attribute universe is represented by the symbol U,Arepresents an access structure which consists of U’s non-empty subsets, i.e., A⊆2U\{0}. For any B, C⊆ U, ifB⊆CandB∈A, then C∈A, it is said to be monotone. From the point of comprehensibility, monotonicity suggests that a larger attribute set implies greater privileges, so adding attributes to an attribute set does not reduce its privileges but only makes it more powerful. A boolean formula Tcorresponds to an access structure A= (M, τ)where Mis a matrix and τis a function. The boolean formula Tdetermines the number of rows and columns of matrix Mandτmaps M’s row to a specific attribute. Some simple and efficient conversion methods were proposed. For instance, in [44], Liu and Cao proposed an efficient algorithm to convert the boolean formula into as small as possible matrix thus reducing the communication cost. The scheme in this work does not involve the secret recov- ery, but only the linear reconfiguration property of linear secret sharing scheme (LSSS [43]) is used, described as follows. LetSbe an attribute set and I={i|i∈ {1, ..., n 1}, τ(i)∈ S}be the set of rows in Mthat corresponding to S. If there is a way to combine the rows of matrix Msuch that the result is equal to (1,0,0, ...,0), then we describe the attribute set S as fulfilling the access structure (M, τ). More formally, if the attribute set Ssatisfies the access structure (M, τ), then there must exist a set of constant coefficients {θi}i∈Isuch that the following equation holdsP i∈IθiMi= (1,0,0, ...,0)where Miis the i-th row of M. We use eA= (fM,ef)to denote the delegation access struc- ture corresponds to boolean formula eTandA′= (M′, f′) to denote the revoked access structure corresponds to boolean formula T′. III. SYSTEM ARCHITECTURE AND DEFINITIONS A. System architecture Our RFAME system requires four entities, which are the data owner (DO), data user (DU), trusted authority center (AC), and cloud server (CS). (1) AC takes charge of setting up the entire system and generating all public parameters according to the securityThis article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 4 parameters. The authority center also uses the master private key to create private keys for the data users. (2) DO makes the access structure and decides who can access its data accordingly. Data is encrypted under the specified access structure and transferred to the cloud. (3) CS keeps the ciphertext uploaded by data owner and performs the revocation operation. (4) Data users are able to obtain the ciphertext and recover the plaintext with their own secret key. Data users also can confirm the data integrity. B. Threat model Threat models are used to portray adversaries. Different adversaries have different capabilities and goals, this paper deals with two adversaries in the threat model [22]. The first adversary can be any entity whose main target is to compromise the confidentiality of the data. This adversary doesn’t possess a valid key, but their goal is to decrypt the ciphertext to achieve the plaintext. The second adversary, typically represented by a CS, aims to tamper with the data integrity by generating incorrect revoked ciphertext. This means that they want to corrupt the data in a way that makes it unreliable or misleading. Note that the threat model assumes there is no collaboration between CS and the revoked user. In other words, CS won’t share the original ciphertext with the revoked user, as doing so would allow the revoked user to decrypt it directly. C. Syntax of Revocable FAME with Data Integrity (RFAME- DI) Our RFAME-DI scheme is comprised of the following seven algorithms. The process of execution is depicted in Fig.2. Setup(1λ): The security parameter λis provided as input to the authority center, which then generates the system public parameters PP and the master private key msk . KeyGen( msk,S): The authority center produces the private keyskfor the data user by entering the master private key msk and the attribute set Scorresponding to data user. Encrypt( m,A, PP): The data owner uses the access struc- tureAto encrypt the message mand then outputs the ciphertext CT. Delegate( eA): The data owner takes the delegation access structure eAas input, and then computes and takes the delega- tionDG based on the new attributes involved in eAas output. Revoke( CT, DG ): The cloud server takes the original ci- phertext CT and the delegation DG as input and takes the revoked ciphertext CT′whose corresponding access structure isA′as output. The boolean formula corresponding to A′here isT′= (TANDeT). Decrypt or(sk, CT ): The data user takes their private key skand the original ciphertext CTas input, where the private key corresponds to the attribute set Sand the access structure contained in the ciphertext CT isA. It outputs the message m, when the attribute set Smatches Aand the calculated checksum equals the checksum embedded in CT, else it outputs ⊥. Authority center Secret key Data owner Data owner Cloud server Cloud server Cloud server Public key Public key Upload: CT Upload: DG Download: Ciphertext Data user 1. Verify integrity (included in the Decrypt) 2. Recover the message m Data user 1. Verify integrity (included in the Decrypt) 2. Recover the message m Fig. 2. Our RFAME-DI scheme’s system architecture Decryptre(sk′, CT csum, CT′): The data user takes their private key sk′which is different from sk, a part of the original ciphertext CTcsum (explicitly, it is the checksum in CT.) and the revoked ciphertext CT′downloaded from the cloud server as input if the attribute set S′about the private key sk′matches the access structure A′in the ciphertext CT′and the calculated checksum equals the CTcsum and the checksum embedded in CT′, then it outputs the message m, else it outputs ⊥. D. Security model The two security models [22] required for the RFAME-DI scheme are described separately below. IND-CPA security. Informally, if no algorithm can distinguish between m0 andm1encrypted under the chosen access structure A∗, the scheme resists the chosen plaintext attack (CPA), as long as the algorithm is not authorized with the corresponding decryption key. Such an attack occurs at any stage of the cryptographic scheme, so the choice of the attacked access structure A∗ depends on the private key and the public parameters pos- sessed by the adversary. The scheme considered in this case will obtain adaptive or full security. In a less robust model referred to as selective security, the access structure A∗is selected before the system is deployed so as to prevent CPA, such an idealized definition is unlikely to occur in reality. A RFAME-DI scheme achieves CPA security when the A’s advantage in the subsequent game is negligible. Setup: The challenger Cruns the scheme’s Setup algorithm to produce public parameters and a master secret key during this phase. The public parameters are then shared by Cand A. Query: Asubmits a query to obtain the secret keys skS1, ..., sk Sq1, where Sican’t satisfy the access structure A∗that will be challenged for i∈ {1,2, ..., q 1}.Aalso makes a delegation text query and gets a series of delegation texts dt1, dt2, ..., dt q2.This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 5 Challenge: Achooses message m0and message m1of the same bit length. These messages are then sent to CbyA. Ctakes these messages and generates a challenge ciphertext CT∗by executing the algorithm Enc(mσ,A∗). Here, σis a randomly chosen value from the set {0,1}.Cthen sends the CT∗back to A. Query: This phase is the same as above. Guess: A’s advantage in winning the IND-CPA secu- rity game is defined by the equation AdvIND−CPA A (λ) = |Pr[σ′=σ]−1/2|, where σ′is the adversary’s guess for σ. Integrity. The data integrity of the RABE-DI scheme is captured by the game involving CandA. The scheme guarantees data integrity if the advantage of an adversary Ais negligible. Setup: Cruns the scheme’s Setup algorithm to produce public parameters and a master secret key during this phase. The public parameters are then shared by CandA. Query: Asubmits a query to obtain the secret keys skS1, ..., sk Sq. Challenge: Aselects a message mand an access structure Aand then transmits them to C.Cencrypts mby algorithm Enc(m,A)and returns it’s result CTback to A. Query: This phase is the same as above. Output: Aproduces an attribute set S′and a revoked ciphertext CT′.Ais considered to win if Decre(skS′, CT, CT′) =m′, where m′is neither mnor⊥. We notate the A’s advantage in winning the integrity game is Pr[Awins ]. IV. CONSTRUCTION In this part, we begin by presenting a revised version of the FAME construction, which includes an additional commitment to the ciphertext. Subsequently, we demonstrate that this modified version of FAME offers full security. Furthermore, we proposed the revocable FAME scheme with data integrity. The meaning of the mathematical symbols involved in the scheme are shown in Table I below. A. FAME scheme with data integrity The scheme comprises four algorithms as follows. Setup(1λ): Let (p,G,H,GT, e, g, h )be a prime order bi- linear group system. Authority center selects α1, α2randomly fromZ∗ pand selects γ1, γ2, γ3randomly from Zpand com- putes H1=hα1, H2=hα2, T1=e(g, h)γ1α1+γ3, T2= e(g, h)γ2α2+γ3. Authority center also chooses two hash func- tionH:{0,1}∗→Gand H :GT→Z∗ pand selects φ, ϕ randomly from G, then authority center outputs public parameters PP= (g, h, H 1, H2, T1, T2, φ, ϕ,H,H). Authority center selects β1, β2randomly from Z∗ pand outputs the master private key msk = (α1, α2, β1, β2, gγ1, gγ2, gγ3). KeyGen( msk, S ): Authority center selects r1, r2ran- domly from Zp, and uses β1, β2to compute sk0= (hβ1r1, hβ2r2, hr1+r2). We use sk0,1, sk0,2, sk0,3to represent the three subterms of sk0. Authority center selects σy, σ′ randomly from Zp. For z= 1,2and all y∈ S, authority center computesTABLE I SYMBOL DESCRIPTION LIST Symbols Description λ Security parameter PP Public parameters (S, sk0,{sky}y∈S, sk′) Private key for attribute set S H Hash function mapping {0,1}∗toG H Hash function mapping GTtoZ∗ p M Matrix with n1rows and n2columns τ Row labeling function col1 First column of matrix M S Attribute set y Attribute in the attribute set S m, m′Message and random value from GT e Bilinear map function ei Ciphertext for m′ ⊥ Data integrity exception symbol sky,z=H(y1z)β1r1 αz· H(y2z)β2r2 αz· H(y3z)r1+r2 αz·gr1+r2 αz, sk′ z=gγz·H(011z)β1r1 αz·H(012z)β2r2 αz·H(013z)r1+r2 αz·gσ′ αz. Authority center lets sky= ( sky,1, sky,2, g−σy), sk′= ( sk′ 1, sk′ 2, gγ3−σ′ )and outputs secret key sk= (S, sk0,{sky}y∈S, sk′)for attribute set S. Encrypt( m,A, PP): Data owner selects s1, s2andˆs1,ˆs2 from Zprandomly, computes c0= (c0,1, c0,2, c0,3) = (Hs1 1, Hs2 2, hs1+s2)ande0= (e0,1, e0,2, e0,3) = ( Hˆs1 1, Hˆs2 2, hˆs1+ ˆs2). Suppose that Mis a matrix of n1×n2andMi,jis an element of M, where iandjrepresent the row and column number, respectively. For k= 1,2,3andi= 1, ..., n 1, the data owner computes ci,k=H(τ(i)k1)s1· H(τ(i)k2)s2· Qn2 j=1[H(0jk1)s1· H(0jk2)s2]Mi,j, Data owner lets ci= (ci,1, ci,2, ci,3)and computes ct′= Ts1 1·Ts2 2·m, where message mbelongs to group GT, and then data owner selects m′fromGTrandomly. For k= 1,2,3 andi= 1, ..., n 1, the data owner computes ei,k=H(τ(i)k1)ˆs1· H(τ(i)k2)ˆs2· Qn2 j=1[H(0jk1)ˆs1· H(0jk2)ˆs2]Mi,j, Data owner lets ei= (ei,1, ei,2, ei,3)and computes ct′′= Tˆs1 1·Tˆs2 2·m′,csum =φH(m)ϕH(m′). Data owner outputs ciphertext CT = (A, c0, c1, ..., c n1, ct′, e0, e1, ..., e n1, ct′′, csum ). Decrypt or(sk, CT ): Data user checks whether the private key’s attribute set Smatches the ciphertext’s access structure A= (M, τ). If not, the algorithm aborts after printing the error symbol ⊥. Otherwise, the data user performs the following operations. Data user finds the set I⊂ {1,2, ..., n 1}andI= {j:τ(j)∈ S} and then finds a constant set {θi}i∈Ithat satisfyP i∈Iθi·Mi= (1,0, ...,0). Data user computesThis article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 6 num = ct′·e(Q i∈Icθi i,1, sk0,1)·e(Q i∈Icθi i,2, sk0,2)·e(Q i∈Icθi i,3, sk0,3), den=e(sk′ 1·Q i∈Iskθi τ(i),1, ct0,1)·e(sk′ 2·Q i∈Iskθi τ(i),2, ct0,2)·e(sk′ 3·Q i∈Iskθi τ(i),3, ct0,3), and outputs m=num/den . A similar calculation can be performed for (e0, e1, ..., e n1, ct′′)and outputs m′. At last, ifcsum =φH(m)ϕH(m′)holds, the data user outputs m, otherwise outputs ⊥. Correctness. Here we demonstrate that when the private keyskincludes the necessary attributes in Aof a valid FAME ciphertext, our decryption algorithm will always recover the correct message with a certainty of 1. From the ct′we know that if we wish to get m, the essence is that we need to compute Ts1 1·Ts2 2. For k= 1,2,3, using the equationP i∈IθiMi= (1,0,0, ...,0), we can calculateQ i∈Icθi i,k. Y i∈Icθi i,k=Y i∈I(H(τ(i)k1)θis1· H(τ(i)k2)θis2·n2Y j=1[H(0jk1)s1· H(0jk2)s2]θiMi,j) =n2Y j=1[H(0jk1)s1· H(0jk2)s2]P i∈IθiMi,j· (Y i∈I(H(τ(i)k1)θis1· H(τ(i)k2)θis2) = [H(01k1)s1· H(01k2)s2]P i∈IθiMi,j· (Y i∈I(H(τ(i)k1)θis1· H(τ(i)k2)θis2) This allows us to compute the last three pairing operations innum , we calculate num/ct′=Q t∈{1,2}[e(H(011t), h)β1r1st·e(H(012t), h)β2r2st· e(H(013t), h)(r1+r2)st·Q i∈I(e(H(τ(i)1t)θi, h)β1r1st· e(H(τ(i)2t)θi, h)β2r2st·e(H(τ(i)3t)θi, h)(r1+r2)st)]. When the above num/ct′and the related term in den are eliminated, we get the inverse of (Q t∈{1,2}e(gγt·gσ′ αt·Q i∈Igθiστ(i) αt, hαtst))·e(gγ3·g−σ′ ·Q i∈Ig−θiστ(i), hs1+s2) Simply organizing the above term we get e(g, h)γ1α1s1+γ2α2s2+γ3(s1+s2), it is evident that this is theTs1 1·Ts2 2we want. Hence, the message mis recovered successfully. Similarly, we can obtain m′. B. RFAME-DI scheme The RFAME-DI scheme is a further improvement on the FAME scheme with data integrity. The Setup ,KeyGen , Encrypt ,Decrypt orof our RFAME-DI scheme is the same as the scheme above. To achieve revocation, we add three algorithms Delegate ,Revoke andDecryptreas described below.To perform a revocation of a file, the cloud needs a delegation DG provided by the data owner of this file and the cloud performs the revocation algorithm based on the DG. To implement the delegation, the data owner randomly selects s1, s2and saves s1, s2as a file identifier for that file during the encryption phase. In the delegation phase, the data owner needs to use s1, s2to generate the dtwhich is a part of DG. Delegate( eA): The data owner specifies an access structure eA= (fM,eτ), where fMis afn1×fn2matrix and eτis a function that converts a row from the matrix fMinto an attribute. Then the following calculation is done for the new attributes contained in the access structure eAandk= 1,2,3. dtk=Qfn1 i=1H(eτ(i)k1)s1· H(eτ(i)k1)s2 Data owner lets dt= (dt1, dt2, dt3)and outputs delegation DG= (dt,eA)for the could server. Revoke( CT, DG ): The cloud server inputs a ciphertext CT= (A, c0, c1, ..., c n1, ct′, e0, e1, ..., e n1, ct′′, csum )and a delegation DG= (dt,eA).Mis a matrix with n1rows and n2columns and fMis a matrix with fn1rows and fn2columns. The cloud server produces a revoked ciphertext under access structure A′= (M′, τ′). The cloud server constructs (M′, τ′) as M′= M| −col1|0 0| fM , τ′=( τ(j) j≤n1 eτ(j−n1)j > n 1 where col1is first column of M.M′is an′ 1×n′ 2matrix, where n′ 1=n1+fn1, n′ 2=n2+fn2. The cloud selects s′ 1, s′ 2 fromZprandomly and computes revoked ciphertext ¯ct′=ct′·Ts′ 1 1·Ts′ 2 2,¯c0= (c0,1·Hs′ 1 1, c0,2·Hs′ 2 2, c0,3·hs′ 1+s′ 2), ¯ci,k=ci,k·H(τ(i)k1)s′ 1·H(τ(i)k2)s′ 2·Qn′ 2 j=1[H(0jk1)s′ 1· H(0jk2)s′ 2]M′ i,j, where i∈[1, n1]. ¯ci,k=dtk· H(τ(i)k1)s′ 1· H(τ(i)k2)s′ 2·Qn′ 2 j=1[H(0jk1)s′ 1· H(0jk2)s′ 2]M′ i,j, where i∈[n1+ 1, n′ 1]. The cloud server lets ¯ci= (¯ci,1,¯ci,2,¯ci,3)forifrom 1to n′ 1andcsum =csum . The ¯e0,¯e1, ...,¯en1can be gotten in the same way as above. The revoked ciphertext is CT′= (A′,¯c0,¯c1, ...,¯cn′ 1,¯ct′, ¯e0,¯e1, ...,¯en′ 1,¯ct′′,csum ). Decryptre(sk′, CT csum, CT′): The data user enters the private key sk′, which corresponds to the attribute set S′. The data user also enters the checksum in original ciphertext CTcsum and revoked ciphertext CT′. First, the data user verifies whether csum is equal to CTcsum . If not, the data user outputs an error symbol ⊥and aborts. In the second step, the data user checks if the attribute set S′meets the access structure (M′, τ′). If it doesn’t satisfy, the algorithm aborts after printing ⊥. Otherwise, the data user finds a set I′⊂ {1,2, ..., n′ 1}where I′={j:τ′(j)∈ S′}and a set of constants {θ′ i}i∈I′which elements belong to Z∗ p. Such thatThis article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 7 P i∈I′θ′ i·M′ i= (1,0,0, ...,0). Then, the data user calculates mandm′in the same way as in Decryptor. At last, the data user checks whether csum =φH(m)ϕH(m′). If the equation holds, the algorithm exports m, else prints ⊥. Note that Decrypt recan be considered as three execution phases: pre-verification, decryption, and verification. The pre- verification is to save computational cost for the user when the data integrity has been broken. If the cloud server tampers with the checksum of original ciphertext, which makes it unequal to the checksum of CT′, this will cause an exception to be thrown from the pre-validation phase when the user executes Decrypt re. However, this does not do the cloud server any favors and invites recourse from the user, who may believe that the cloud server has compromised the integrity of the data. This may result in the user refusing to pay the cloud service provider. A failure in the pre-verification and verification phases throws an exception of data integrity. Therefore it is reasonable to assume that the cloud server will not tamper with CTsum to affect the execution result of the user’s algorithm Decrypt re. Furthermore, in practice, the data owner can generate signature for the checksum of each ciphertext he uploads so that the cloud server cannot forge it. Correctness. Algorithm Decryptreis the equivalent of the original decryption algorithm Decryptorexcept for the first step, the checksum of the original ciphertext CTcsum is compared with the checksum in the revoked ciphertext CT′. Therefore, as long as CT′is a valid ciphertext under the access structure (M′, τ′), algorithm Decryptrenaturally satisfies the correctness. In the following, we show that the CT′produced through Revoke is correct by lemma 1. Lemma 1. If the above MandfMare valid LSSS access structures, then M′is a valid LSSS access structure, and vice versa. proof : Due to the fact that both (M, τ)and (fM,eτ) are valid, there are two sets of constants {θi}i∈[1,n1]and {eθi}i∈[1,fn1]which elements both belong to Z∗ p, such thatP i∈[1,n1]θi·Mi= (1,0,0, ...,0)∈Zn1pandP i∈[1,fn1]eθi· fMi= (1 ,0,0, ...,0)∈Zfn1p, respectively. We can then use {θi}i∈[1,n1]and{eθi}i∈[1,fn1]to construct {θ′ i}i∈[1,n′ 1]in the following way, where n′ 1=n1+fn1. θ′ i=( θi , i∈[1, n1] eθi−n1, i∈[n1+ 1, n′ 1] It is easy to deduce from the formula that, X i∈[1,n′ 1]θ′ i·M′ i=X i∈[1,n1]θi·M′ i+X i∈[1,fn1]eθi·M′ i+n1 = (n1z}|{ 1,0, ...,0,fn1z}|{ −1,0, ...,0) + (n1z}|{ 0, ...,0,fn1z}|{ 1,0, ...,0) = (1,0,0, ...,0)∈Zn′ 1p Thus, (M′, τ′)is valid LSSS access structures. Conversely, if (M′, τ′)is valid, there exists a set of con- stants{θ′ i}i∈[1,n′ 1]which elements both belong to Z∗ p, such thatP i∈[1,n′ 1]θ′ i·M′ i= (1,0,0, ...,0)∈Zn′ 1p. We can construct {θi=θ′ i}i∈[1,n1]and{eθi=θi+n1}i∈[1,fn1]such that X i∈[1,n′ 1]θ′ i·M′ i= (1,0,0, ...,0) = (n1z}|{ 1,0, ...,0,fn1z}|{ −1,0, ...,0) + (n1z}|{ 0, ...,0,fn1z}|{ 1,0, ...,0) =X i∈[1,n1]θi·M′ i+X i∈[1,fn1]eθi·M′ i+n1 = (X i∈[1,n1]θi·Mi,X i∈[1,n1]θi·(fn1z}|{ −col1,i,0, ...,0)) + (X i∈[1,fn1]eθi·n1z}|{ (0, ...,0),X i∈[1,fn1]eθi·fMi). From the above equation it can be inferred thatP i∈[1,n1]θi· Mi= (1 ,0,0, ...,0)∈Zn1pandP i∈[1,fn1]eθi·fMi= (1,0,0, ...,0)∈Zfn1p. Thus, the LSSS access structures M andfMare both valid. V. SECURITY ANALYSIS First, we prove the confidentiality of the modified FAME scheme by reducing it to the original FAME scheme. We then demonstrate the semantic security of the proposed revocable FAME with data integrity scheme. Finally, we give a data integrity proof of our formal scheme by reducing to the discrete logarithm assumption. Theorem 1. The FAME with data integrity scheme is fully IND-CPA secure if Shashank’s FAME scheme [17] is fully IND-CPA secure. Proof : The simulator Bcan be built to break the underlying FAME scheme’s full security by communicating with the challenger C, if a Aexists that can break the security of FAME-DI scheme. • Setup. Bobtains the basic parameters (p,G,H,GT, e, H 1, H2, T1, T2,H)by calling C, where H1=hα1, H2= hα2, T1=e(g, h)γ1α1+γ3, T2=e(g, h)γ2α2+γ3.Bfirst selects a hash H that maps from GTtoZ∗ p, and then randomly selects two elements ϕ, φ from the group G. Then Badds these to the base parameters to form the public parameters PP= (ϕ, φ, H 1, H2, T1, T2,H,H)toA, and sends them to A. • Query. Aqueries a private key, then Bqueries a private key to Con the attribute set Swhich is the same as the query of A. Then Bforwards the return of CtoA.Acan also initiate a delegation query to access structure eA= (fM,eτ).Brandomly selects two random numbers saandsband computes dtk=Qfn1 i=1H(eτ(i)k1)sa· H(eτ(i)k1)sb, sets dt= (dt1, dt2, dt3), thenBforwards dttoA. • Challenge. Asends message m0and message m1of the same bit length and the access structure A∗= (M∗, τ∗) intended to be challenged to B.Bforwards m0, m1andA∗to C.Ctosses a random coin to determine the value of σ∈ {0,1}This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 8 based on its tails and sends the challenge ciphertext about mσ encrypted with A∗toB, denote as (A∗, c0, c1, ..., c n1, ct′). Bselects m′∈G, Q∈GTand ˆs1,ˆs2fromZprandomly. The simulator Bcomputes e0= (Hˆs1 1, Hˆs2 2, hˆs1+ ˆs2)and for k= 1,2,3andi= 1, ..., n 1,Bcomputes ei,k=H(f(i)k1)ˆs1· H(f(i)k2)ˆs2·Qn2 j=1[H(0jk1)ˆs1·H(0jk2)ˆs2]M∗ i,j.Bsetsei= (ei,1, ei,2, ei,3). Then Bcomputes ct′′=Tˆs1 1·Tˆs2 2·m′and setscsum =Q. Eventually Bsets challenge ciphertext CT= ((M∗, f∗), c0, c1, ..., c n1, ct′, e0, e1, ..., e n1, ct′′, csum )and forwards it to A. • Query. This phase is the same as above. • Output. Agives its guess σ′onσ,Balso guesses σas σ′. Analysis. IfAcan break our modified scheme, Bhas the same advantage to compromise the FAME scheme. The simulation in the game works perfectly, except that during the challenge phase, instead of providing the calculated check value csum =φH(m)ϕH(m′),Breturns a random value Qfrom the group GT. The important point is that Ais unaware of the value of m′, so the random value Qhas the same statistical distribution as the calculated check value csum . This means that the computed csum and the random value Qlook the same from A’s perspective. Theorem 2. The revocable FAME with data integrity scheme is fully IND-CPA secure if the modified FAME scheme is fully IND-CPA secure. Proof : First, in the revocable FAME with data integrity scheme, the ciphertext generated by encryption algorithm Encrypt before revocation is the same as the ciphertext in the modified FAME scheme. We call the ciphertext generated byEncrypt the original ciphertext, so the original ciphertext generated by encryption in RFAME-DI achieves the same full security as the modified FAME scheme. Second, we show that the revoked ciphertext generated by the revocation Revoke and the ciphertext produced during encryption are identically distributed, i.e., these two are indistinguishable from the adversary’s view. In our RFAME-DI scheme, the ciphertext generated by the Revoke is the elements in the GT generated by the value s1+s′ 1ands2+s′ 2. Where s′ 1, s′ 2 are chosen randomly and s1, s2are in the original ciphertext. So in the adversary’s view s1+s′ 1ands2+s′ 2are also chosen randomly. Thus the revocation ciphertext generated with random value s1+s′ 1, s2+s′ 2and the ciphertext generated by directly encrypting under the access structure (M′, τ′)with randomly selected value s′′ 1, s′′ 2are identically distributed, i.e., indistinguishable from the adversary’s viewpoint. Theorem 3. If the discrete logarithm assumption holds, the revocable FMAE scheme captures the data integrity. Proof : If a malicious Aattempts to compromise the RFAME-DI scheme’s integrity, it implies the existence of sim- ulator Bto address the discrete logarithm problem. Simulator Binputs a discrete logarithm instance, represented by the parameters (p,G,GT, e, g, gζ). Its objective is to get the ζ as the output. • Setup. Bsets a bilinear group system of prime order (p,G,GT, e, g).Bselects α1, α2, β1, β2randomly from Z∗ pand select γ1, γ2, γ3, µrandomly from Zp, then chooses two hash function H :GT→Z∗ pandH:{0,1}∗→GT.Blets φ=gζ, ϕ=gµand computes H1=hα1, H2=hα2, T1= e(g, h)γ1α1+γ3, T2=e(g, h)γ2α2+γ3. Then Bsends the public parameters PP= (φ, ϕ, H 1, H2, T1, T2,H,H)toA. • Query. Aqueries a private key on the attribute set S. AsB holds the master private key msk = (g, h, α 1, α2, β1, β2, gγ1, gγ2, gγ3),Bcan generate the skSand provide it to A. • Challenge. Aselects an access structure A= (M, f) and a message mand provides them to the B. Note that here Bis both the simulator and the challenger. The simulator Bruns the Encrypt( m,(M, τ))to obtain CT= (A, c0, c1, ..., c n1, ct′, e0, e1, ..., e n1, ct′′, csum ), where csum =φH(m)ϕH(m′)andm′is randomly selected during the encryption process. Bsends CTto the A. • Query. This phase is the same as above. • Output. Agives a revoked ciphertext under the revoked access structure CT′= (A′= (M′, τ′),¯c0,¯c1, ...,¯cn′ 1,¯ct′,¯e0, ¯e1, ...,¯en′ 1,¯ct′′,csum ). At this point, simulator Bcan choose an attribute set S′ that satisfies the revoked access structure M′and then use the master private key to generate the corresponding private keyskS′, which is then used to decrypt CT′to obtain the encrypted message. Denote the decrypted real message and random message to be ¯mand¯m′respectively. If Acan break data integrity, then it means ¯m̸=mand¯m′̸=m′butcsum = csum . So that Bcan calculate ζby the following computation and return ζas its answer for discrete logarithm assumption. csum =csum⇔φH(m)ϕH(m′)=φH( ¯m)ϕH(¯m′) ⇔gζ·H(m)+µ·H(m′)=gζ·H( ¯m)+µ·H(¯m′) ⇔ζ·(H(m)−H( ¯m)) =µ·(H(¯m′)−H(m′)) ⇒ζ=µ·(H(¯m′)−H(m′)) H(m)−H( ¯m). Analysis. The simulation of Bin the game is flawless, and theB’s advantage in solving the discrete logarithmic hard problem is identical to the adversary A’s advantage in winning the above game. VI. IMPLEMENTATION & EVALUATION We put our scheme into action and assess its feasibility by considering the computational expenses involved, we also do a property-wise comparison of our scheme with other RABE schemes [22], [27], [31], [45] in Table II. We implement our scheme on a laptop with AMD’s CPU. It’s Ryzon 7 5800H @3.2GHz with 4GB RAM. Both the client and cloud server utilize the Linux Ubuntu 20.04 operating system. We use the library charm 0.5.0 in Python to write the code and run it with version 2.7.15 of Python. It is possible to carry our scheme on type III curves, such as MNT and BN curves, but some MNT and BN curves are known to be insecure in some parameters, so be sure to choose elliptic curves carefully when implementing cryptographic schemes. We implement our scheme on the type III curve MNT224This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 9 TABLE II COMPARISON OF VARIOUS RABE SCHEMES Scheme Type of revocation Data integrity Attribute space Arbitrary attributes Security Computation Cost in decryption [22] Re-encryption Yes Bounded No Selective Linear [27] Direct No Bounded No Selective Linear [31] Indirect No Bounded No Selective Constant [45] Indirect No Unbounded Yes Full Constant Ours Re-encryption Yes Unbounded Yes Full Constant in PBC, which is widely acknowledged for its exceptional balance between security and efficiency. Since there are AND-gates and OR-gates in the randomly generated access structure, how many attributes are used in decryption is not determined by the access structure size, and only some attributes are needed to participate in the calculation to complete the decryption. Therefore, the access structure we generate for testing only contains AND-gates, the goal is to ensure that the amount of attributes needed for decryption matches the access structure size. We also do the same test 50 times and averaged the results to get more realistic and accurate time data. Specifically in the experiment, for the three algorithms Encrypt ,Decryptor, and Revoke , the attribute set and access structure are adjusted in increments of 10, ranging from a minimum of 10 to a maximum of 100. The horizontal coordinates of the experimental images of Revoke represent the size of A′. For the algorithm Decryptre, the access structure size is from 20 to 200 with a step of 20. In fact, there is no difference between the two algorithms Decryptorand Decryptre, butDecryptredoes one more equation verification operation than Decryptor, i.e., verifying whether the CTcsum item from the original ciphertext is equal to csum in the revoked ciphertext, and this operation is very light and its time consumption is negligible. We can see from the Fig.4 and Fig.6 that the performance of the Decryptrealgorithm is almost the same as that of the Decryptoralgorithm in the set size range from 10 to 100. /s48 /s50/s48 /s52/s48 /s54/s48 /s56/s48 /s49/s48/s48/s48/s50/s48/s48/s52/s48/s48/s54/s48/s48/s56/s48/s48/s49/s48/s48/s48/s69/s110/s99/s114/s121/s112/s116/s105/s111/s110/s32/s40/s109/s115/s41 /s65/s99/s99/s101/s115/s115/s32/s112/s111/s108/s105/s99/s121/s32/s115/s105/s122/s101/s32/s79/s117/s114/s32/s83/s99/s104/s101/s109/s101 /s32/s83/s99/s104/s101/s109/s101/s91/s49/s56/s93 Fig. 3. Encryption time of RFAME-DI scheme and compared scheme We compare our scheme with the scheme [22]. From Fig.6- 9, we see that our scheme outperforms the scheme [22] in all four phases: encryption, decryption, revocation, and decryption /s48 /s50/s48 /s52/s48 /s54/s48 /s56/s48 /s49/s48/s48/s48/s49/s48/s48/s50/s48/s48/s51/s48/s48/s52/s48/s48/s53/s48/s48/s54/s48/s48/s68/s101/s99/s114/s121/s112/s116/s105/s111/s110/s32/s40/s109/s115/s41 /s65/s116/s116/s114/s105/s98/s117/s116/s101/s32/s115/s101/s116/s32/s115/s105/s122/s101/s32/s79/s117/s114/s32/s83/s99/s104/s101/s109/s101 /s32/s83/s99/s104/s101/s109/s101/s91/s49/s56/s93Fig. 4. Decryption time of RFAME-DI scheme and compared scheme /s48 /s53/s48 /s49/s48/s48 /s49/s53/s48 /s50/s48/s48/s48/s53/s48/s48/s49/s48/s48/s48/s49/s53/s48/s48/s50/s48/s48/s48/s82/s101/s118/s111/s99/s97/s116/s105/s111/s110/s32/s40/s109/s115/s41 /s82/s101/s118/s111/s107/s101/s100/s32/s97/s99/s99/s101/s115/s115/s32/s112/s111/s108/s105/s99/s121/s32/s115/s105/s122/s101/s32/s79/s117/s114/s32/s83/s99/s104/s101/s109/s101 /s32/s83/s99/s104/s101/s109/s101/s91/s49/s56/s93 Fig. 5. Revocation time of RFAME-DI scheme and compared scheme of the revoked ciphertext. Especially in the decryption phases, where the time consumed in our scheme for decryption is independent of the set size, which is stable at about 36ms regardless of the set size. This is because the decryption process of FAME only needs 6 pairing operations. Our scheme has acceptable disadvantages and very large advantages in practical applications. Because the KGC, which has adequate computational capability, manages key generation and the algorithm is usually executed only once for one user. The client device handles both encryption and decryption tasks, so it’s crucial for the computational load to be as minimal as possible. Since ABE is a one-to-many encryption technique, so decryption occurs more frequently than encryption in practical scenarios. Our scheme happens to exactly has a significant advantage in decryption.This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 10 /s48 /s53/s48 /s49/s48/s48 /s49/s53/s48 /s50/s48/s48/s48/s50/s48/s48/s52/s48/s48/s54/s48/s48/s56/s48/s48/s49/s48/s48/s48/s49/s50/s48/s48/s82/s101/s118/s111/s107/s101/s100/s32/s99/s105/s112/s104/s101/s114/s116/s101/s120/s116/s32/s100/s101/s99/s114/s121/s112/s116/s105/s111/s110/s32/s40/s109/s115/s41 /s65/s99/s99/s101/s115/s115/s32/s112/s111/s108/s105/s99/s121/s32/s115/s105/s122/s101/s32/s79/s117/s114/s32/s83/s99/s104/s101/s109/s101 /s32/s83/s99/s104/s101/s109/s101/s91/s49/s56/s93 Fig. 6. Revoked ciphertext decryption time of RFAME-DI scheme and compared scheme The outcomes of the experiment show the effectiveness and feasibility of our revocation scheme in ensuring data integrity. VII. CONCLUSION In this paper, we introduce a practical and effective RFAME scheme designed to safeguard the data integrity on the cloud, thereby minimizing performance limitations both for the data users and the cloud. We reduce the security of our scheme to the FAME scheme to show its full security. We also demonstrate the data integrity of our scheme in an adaptive model under discrete logarithm assumption. Furthermore, we conduct simulation experiments and experimental analysis in- dicates that our scheme’s efficiency surpasses the comparison scheme in encryption, decryption, and revocation algorithms. In addition, our scheme achieves efficient attribute-based re- vocation while protecting data integrity, but the essence of revocation is an update of the access structure. It will affect the access of some data users to the file. Our future work is to implement more fine-grained revocation, enabling data owners to withdraw access to a single file for a specific user. REFERENCES [1] Z. Kang, J. Li, J. Shen, J. Han, Y . Zuo, and Y . Zhang, “TFS-ABS: traceable and forward-secure attribute-based signature scheme with constant-size,” IEEE Trans. Knowl. Data Eng. , vol. 35, no. 9, pp. 9514– 9530, 2023. [2] Y . Chen, J. Li, C. Liu, J. Han, Y . Zhang, and P. Yi, “Efficient attribute based server-aided verification signature,” IEEE Trans. Serv. Comput. , vol. 15, no. 6, pp. 3224–3232, 2022. [3] J. Li, Y . Chen, J. Han, C. Liu, Y . Zhang, and H. Wang, “Decentralized attribute-based server-aid signature in the internet of things,” IEEE Internet Things J. , vol. 9, no. 6, pp. 4573–4583, 2022. [4] L. Zhang, H. Xiong, Q. Huang, J. Li, K. R. Choo, and J. Li, “Cryptographic solutions for cloud storage: Challenges and research opportunities,” IEEE Trans. Serv. Comput. , vol. 15, no. 1, pp. 567–587, 2022. [5] A. Sahai and B. Waters, “Fuzzy identity-based encryption,” in 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques . Springer, 2005, pp. 457–473. [6] B. Waters, “Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization,” in 14th International Confer- ence on Practice and Theory in Public Key Cryptography , vol. 6571. Springer, 2011, pp. 53–70. [7] K. B. Frikken, M. J. Atallah, and J. Li, “Attribute-based access control with hidden policies and hidden credentials,” IEEE Trans. Computers , vol. 55, no. 10, pp. 1259–1270, 2006.[8] A. Sahai, H. Seyalioglu, and B. Waters, “Dynamic credentials and ciphertext delegation for attribute-based encryption,” Advances in Cryp- tology - CRYPTO 2012, LNCS , vol. 7417, pp. 199–217, 2012. [9] R. Zhang, J. Li, Y . Lu, J. Han, and Y . Zhang, “Key escrow-free attribute based encryption with user revocation,” Inf. Sci. , vol. 600, pp. 59–72, 2022. [10] Y . Guo, Z. Lu, H. Ge, and J. Li, “Revocable blockchain-aided attribute- based encryption with escrow-free in cloud storage,” IEEE Trans. Computers , vol. 72, no. 7, pp. 1901–1912, 2023. [11] J. Li, R. Zhang, Y . Lu, J. Han, Y . Zhang, W. Zhange, and X. Dong, “Multi-authority attribute-based encryption for assuring data deletion,” IEEE Systems Journal , 2022. [12] J. Li, Y . Zhang, J. Ning, X. Huang, G. S. Poh, and D. Wang, “At- tribute based encryption with privacy protection and accountability for cloudiot,” IEEE Trans. Cloud Comput. , vol. 10, no. 2, pp. 762–773, 2022. [13] J. Hur and D. K. Noh, “Attribute-based access control with efficient re- vocation in data outsourcing systems,” IEEE Trans. Parallel Distributed Syst., vol. 22, no. 7, pp. 1214–1221, 2011. [14] J. Li, X. Huang, J. Li, X. Chen, and Y . Xiang, “Securely outsourc- ing attribute-based encryption with checkability,” IEEE Trans. Parallel Distributed Syst. , vol. 25, no. 8, pp. 2201–2210, 2014. [15] J. Li, Y . Wang, Y . Zhang, and J. Han, “Full verifiability for outsourced decryption in attribute based encryption,” IEEE Trans. Serv. Comput. , vol. 13, no. 3, pp. 478–487, 2020. [16] N. Chen, J. Li, Y . Zhang, and Y . Guo, “Efficient CP-ABE scheme with shared decryption in cloud storage,” IEEE Trans. Computers , vol. 71, no. 1, pp. 175–184, 2022. [17] S. Agrawal and M. Chase, “FAME: fast attribute-based message encryp- tion,” in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security . ACM, 2017, pp. 665–682. [18] D. Riepel and H. Wee, “FABEO: fast attribute-based encryption with optimal security,” in Proceedings of the 2022 ACM SIGSAC Confer- ence on Computer and Communications Security , H. Yin, A. Stavrou, C. Cremers, and E. Shi, Eds. ACM, 2022, pp. 2491–2504. [19] M. Ambrona, G. Barthe, R. Gay, and H. Wee, “Attribute-based en- cryption in the generic group model: Automated proofs and new constructions,” in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security . ACM, 2017, pp. 647– 664. [20] R. Ostrovsky, A. Sahai, and B. Waters, “Attribute-based encryption with non-monotonic access structures,” in Proceedings of the 2007 ACM Conference on Computer and Communications Security . ACM, 2007, pp. 195–203. [21] V . Goyal, A. Jain, O. Pandey, and A. Sahai, “Bounded ciphertext policy attribute based encryption,” in Automata, Languages and Programming, 35th International Colloquium , vol. 5126. Springer, 2008, pp. 579–591. [22] C. Ge, W. Susilo, J. Baek, Z. Liu, J. Xia, and L. Fang, “Revocable attribute-based encryption with data integrity in clouds,” IEEE Trans. Dependable Secur. Comput. , vol. 19, no. 5, pp. 2864–2872, 2022. [23] N. Attrapadung, B. Libert, and E. de Panafieu, “Expressive key-policy attribute-based encryption with constant-size ciphertexts,” in Public Key Cryptography - PKC 2011, LNCS , vol. 6571. Springer, 2011, pp. 90– 108. [24] J. Han, W. Susilo, Y . Mu, and J. Yan, “Privacy-preserving decentralized key-policy attribute-based encryption,” IEEE Trans. Parallel Distributed Syst., vol. 23, no. 11, pp. 2150–2162, 2012. [25] J. Li, W. Yao, J. Han, Y . Zhang, and J. Shen, “User collusion avoidance CP-ABE with efficient attribute revocation for cloud storage,” IEEE Syst. J., vol. 12, no. 2, pp. 1767–1777, 2018. [26] J. Li, W. Yao, Y . Zhang, H. Qian, and J. Han, “Flexible and fine- grained attribute-based data storage in cloud computing,” IEEE Trans. Serv. Comput. , vol. 10, no. 5, pp. 785–796, 2017. [27] J. K. Liu, T. H. Yuen, P. Zhang, and K. Liang, “Time-based direct revo- cable ciphertext-policy attribute-based encryption with short revocation list,” in Applied Cryptography and Network Security, ACNS 2018, LNCS , vol. 10892. Springer, 2018, pp. 516–534. [28] Y . Shi, Q. Zheng, J. Liu, and Z. Han, “Directly revocable key-policy attribute-based encryption with verifiable ciphertext delegation,” Inf. Sci. , vol. 295, pp. 221–231, 2015. [29] H. Wang, Z. Zheng, L. Wu, and P. Li, “New directly revocable attribute-based encryption scheme and its application in cloud storage environment,” Clust. Comput. , vol. 20, no. 3, pp. 2385–2392, 2017. [30] Y . Yang, J. K. Liu, K. Liang, K. R. Choo, and J. Zhou, “Extended proxy- assisted approach: Achieving revocable fine-grained encryption of cloud data,” in 20th European Symposium on Research in Computer Security , vol. 9327. Springer, 2015, pp. 146–166.This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply. 11 [31] H. Cui, R. H. Deng, Y . Li, and B. Qin, “Server-aided revocable attribute- based encryption,” in Computer Security - ESORICS 2016, LNCS , vol. 9879. Springer, 2016, pp. 570–587. [32] A. Boldyreva, V . Goyal, and V . Kumar, “Identity-based encryption with efficient revocation,” in Proceedings of the 2008 ACM Conference on Computer and Communications Security . ACM, 2008, pp. 417–426. [33] Y . Jiang, W. Susilo, Y . Mu, and F. Guo, “Ciphertext-policy attribute- based encryption supporting access policy update and its extension with preserved attributes,” Int. J. Inf. Sec. , vol. 17, no. 5, pp. 533–548, 2018. [34] J. Lai, R. H. Deng, C. Guan, and J. Weng, “Attribute-based encryption with verifiable outsourced decryption,” IEEE Trans. Inf. Forensics Secur. , vol. 8, no. 8, pp. 1343–1354, 2013. [35] J. Li, X. Zhao, Y . Zhang, and W. Yao, “Provably secure certificate- based conditional proxy re-encryption,” J. Inf. Sci. Eng. , vol. 32, no. 4, pp. 813–830, 2016. [36] Y . Lu and J. Li, “A pairing-free certificate-based proxy re-encryption scheme for secure data sharing in public clouds,” Future Gener. Comput. Syst., vol. 62, pp. 140–147, 2016. [37] J. Shao, R. Lu, X. Lin, and K. Liang, “Secure bidirectional proxy re- encryption for cryptographic cloud storage,” Pervasive Mob. Comput. , vol. 28, pp. 113–121, 2016. [38] Z. Li, V . Sharma, C. Ma, C. Ge, and W. Susilo, “Ciphertext-policy attribute-based proxy re-encryption via constrained prfs,” Sci. China Inf. Sci., vol. 64, no. 6, 2021. [39] F. Luo, S. M. Al-Kuwari, F. Wang, and K. Chen, “Attribute-based proxy re-encryption from standard lattices,” Theor. Comput. Sci. , vol. 865, pp. 52–62, 2021. [40] C. Ge, W. Susilo, J. Baek, Z. Liu, J. Xia, and L. Fang, “A verifiable and fair attribute-based proxy re-encryption scheme for data sharing in clouds,” IEEE Trans. Dependable Secur. Comput. , vol. 19, no. 5, pp. 2907–2919, 2022. [41] H. Deng, Z. Qin, Q. Wu, Z. Guan, and Y . Zhou, “Flexible attribute- based proxy re-encryption for efficient data sharing,” Inf. Sci. , vol. 511, pp. 94–113, 2020. [42] A. Sadeghi and M. Steiner, “Assumptions related to discrete logarithms: Why subtleties make a real difference,” Advances in Cryptology - EUROCRYPT 2001 , vol. 2045, pp. 244–261, 2001. [43] A. Beimel, “Secure schemes for secret sharing and key distribution,” Ph.D. dissertation, Technion - Israel Institute of Technology, Israel, 1996. [44] Z. Liu and Z. Cao, “On efficiently transferring the linear secret-sharing scheme matrix in ciphertext-policy attribute-based encryption,” IACR Cryptol. ePrint Arch. , p. 374, 2010. [45] S. Xu, J. Ning, J. Ma, G. Xu, J. Yuan, and R. H. Deng, “Revocable policy-based chameleon hash,” in 26th European Symposium on Re- search in Computer Security , ser. Lecture Notes in Computer Science, E. Bertino, H. Shulman, and M. Waidner, Eds., vol. 12972. Springer, 2021, pp. 327–347. ShaoBo Chen received the B.S. degree in math- ematics from Southern University of Science and Technology, China, in 2019. He is working for M.S. degree in the College of Computer and Cyber Secu- rity, Fujian Normal University, Fuzhou, China. His research interests include attribute-based encryption, could security and privacy. Jiguo Li received the Ph.D. degree in computer science from Harbin Institute of Technology, Harbin, China, in 2003. During 2006.9-2007.3, he was a visiting scholar at Centre for Computer and Informa- tion Security Research, University of Wollongong, Australia. During 2013.2-2014.1, he was a visiting scholar in Institute for Cyber Security in the Uni- versity of Texas at San Antonio. From November 2003 to October 2018, he was with the College of Computers and Information, Hohai University, Nanjing, China. He is currently a professor with the College of Computer and Cyber Security, Fujian Normal University, Fuzhou, China. His research interests include cryptography theory and technology, information security, and cloud computing security etc. He has published over 200 research papers in refereed international conferences and journals. His work has been cited more than 5000 times at Google Scholar. He has served as program committee member in over 40 international conferences and served as the reviewers in over 100 international journals and conferences. Yichen Zhang received the Ph.D. degree in the Col- lege of Computer and Information, Hohai University, Nanjing, China in 2015. She is currently an associate professor with the College of Mathematics and In- formatics, Fujian Normal University, Fuzhou, China. Her research interests include cryptography, network security. She has published over 40 research papers in refereed international conferences and journals. Jinguang Han obtained his PhD degree from Uni- versity of Wollongong, Australia, in 2013. He is a professor at the School of Cyber Science and Engineering, Southeast University, China. His re- search interests include cryptography, access control, blockchain, privacy-preserving systems, cloud com- puting and network security. He is a senior member of ACM and IEEE.This article has been accepted for publication in IEEE Internet of Things Journal. This is the author's version which has not been fully edited and content may change prior to final publication. Citation information: DOI 10.1109/JIOT.2023.3325996 © 2023 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See https://www.ieee.org/publications/rights/index.html for more information.Authorized licensed use limited to: Digital University Kerala. Downloaded on November 17,2023 at 05:42:21 UTC from IEEE Xplore. Restrictions apply.